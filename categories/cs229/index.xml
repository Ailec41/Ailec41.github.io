<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS229 on LunaTide's Blog</title><link>https://lunatide.tech/categories/cs229/</link><description>Recent content in CS229 on LunaTide's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>LunaTide's Blog</copyright><lastBuildDate>Sun, 22 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://lunatide.tech/categories/cs229/index.xml" rel="self" type="application/rss+xml"/><item><title>CS229 Lecture 7</title><link>https://lunatide.tech/p/cs229-lecture-7/</link><pubDate>Sun, 22 Feb 2026 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-7/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-7/pic1.jpg" alt="Featured image of post CS229 Lecture 7" /&gt;&lt;h3 id="最优间隔分类器"&gt;最优间隔分类器
&lt;/h3&gt;&lt;p&gt;给定一个训练集，从我们之前的讨论中可以看出，一个自然的想法是试图找到一个最大化（几何）间隔的决策边界，因为这将反映出对训练集的一个非常有信心的预测和一个对训练数据良好的“拟合”。具体而言，这将导致分类器将正和负训练样本用一个“间隙”（几何间隔）分开。&lt;/p&gt;
&lt;p&gt;现在，假设我们得到一个线性可分的训练集；即，可以使用某个分离超平面分离正负样本。我们如何找到达到最大几何间隔的那个？我们可以提出以下优化问题：&lt;/p&gt;
$$
\max_{\gamma, w, b} \ \gamma
$$$$
\text{s.t.} \quad y^{(i)}(w^T x^{(i)} + b) \ge \gamma, \quad i = 1, \dots, m
$$$$
\|w\| = 1
$$&lt;p&gt;即，我们希望最大化 $\gamma$，使得每个训练样本具有至少 $\gamma$ 的函数间隔。$|w| = 1$ 的约束确保函数间隔等于几何间隔，因此我们也保证所有几何间隔至少为 $\gamma$。因此，解决该问题将导致 $(w,b)$ 相对于训练集具有最大可能的几何间隔。&lt;/p&gt;
&lt;p&gt;如果我们能解决上面的优化问题，我们就完成了。但是 $|w| = 1$ 约束是一个棘手的（非凸的）条件，并且这个问题肯定不是我们可以使用标准优化软件来解决的任何格式。所以，让我们尝试将问题转化为更好的问题。考虑：&lt;/p&gt;
$$
\max_{\hat{\gamma}, w, b} \ \frac{\hat{\gamma}}{\|w\|}
$$$$
\text{s.t.} \quad y^{(i)}(w^T x^{(i)} + b) \ge \hat{\gamma}, \quad i = 1, \dots, m
$$&lt;p&gt;这里，我们将最大化 $\hat{\gamma}/|w|$，使得函数间隔都至少为 $\hat{\gamma}$。由于几何间隔和函数间隔的关系为 $\gamma = \hat{\gamma}/|w|$，这将给出我们想要的答案。此外，我们已经摆脱了约束 $|w| = 1$。缺点是我们仍然有一个棘手的（再次，非凸）目标函数 $\hat{\gamma}/|w|$；而且，我们仍然没有任何可以解决这种形式的优化问题的现成软件。&lt;/p&gt;
&lt;p&gt;回想一下我们之前的讨论，我们可以在 $w$ 和 $b$ 上添加任意缩放约束而不改变任何东西。这是我们现在使用的关键想法。我们将引入缩放约束，即 $w,b$ 相对于训练集的函数间隔必须为 1：&lt;/p&gt;
$$
\hat{\gamma} = 1
$$&lt;p&gt;由于将 $w$ 和 $b$ 乘以某个常数将导致函数间隔乘以相同的常数（这是缩放约束），并且实际上我们可以进行重新缩放 $w,b$ 的操作。对上述问题应用此性质，并注意到最大化 $\gamma/|w| = 1/|w|$ 与最小化 $|w|^2$ 相同，我们现在有以下优化问题：&lt;/p&gt;
$$
\min_{w,b} \ \frac{1}{2} \|w\|^2
$$$$
\text{s.t.} \quad y^{(i)}(w^T x^{(i)} + b) \ge 1, \quad i = 1, \dots, m
$$&lt;p&gt;我们现在已经将问题转化为可以高效解决的形式。以上是具有凸二次目标和仅有线性约束的优化问题。它的解为我们提供了&lt;strong&gt;最优间隔分类器&lt;/strong&gt;。这个优化问题可以使用商业二次规划（QP）程序来解决。&lt;/p&gt;
&lt;p&gt;虽然我们现在可以解决问题，但我们后面还是要讨论拉格朗日对偶问题。这将推导出我们的优化问题的对偶形式，它将在允许我们使用核方法（kernel）让最优间隔分类器在非常高维空间中高效运转方面发挥关键作用。对偶形式还将允许我们推导出一种有效的算法来解决上述优化问题，该优化问题通常比通用 QP 软件做得更好。&lt;/p&gt;
&lt;h3 id="拉格朗日对偶"&gt;拉格朗日对偶
&lt;/h3&gt;&lt;p&gt;让我们暂时搁置 SVM 和最大间隔分类器，然后讨论如何解决约束优化问题。&lt;/p&gt;
&lt;p&gt;考虑如下形式的问题：&lt;/p&gt;
$$
\min_{w} \ f(w)
$$$$
\text{s.t.} \quad h_i(w) = 0, \quad i = 1, \dots, l
$$&lt;p&gt;在这种方法中，我们将拉格朗日算子定义为&lt;/p&gt;
$$
\mathcal{L}(w, \beta)=
f(w)+
\sum_{i=1}^{l} \beta_i h_i(w)
$$&lt;p&gt;这里，$\beta_i$ 被称为拉格朗日乘子。然后我们求出 $\mathcal{L}$ 的偏导数并设为零：&lt;/p&gt;
$$
\frac{\partial \mathcal{L}}{\partial w_i} = 0,
\qquad
\frac{\partial \mathcal{L}}{\partial \beta_i} = 0
$$&lt;p&gt;接着求解 $w$ 和 $\beta$。&lt;/p&gt;
&lt;p&gt;在本节中，我们将此推广为带约束的优化问题，在这些问题中我们可能存在不等式以及等式约束。由于时间的限制，我们无法详细介绍拉格朗日二元对偶理论，但我们将给出主要思想和结果，然后应用于我们的最优间隔分类器的优化问题。&lt;/p&gt;
&lt;p&gt;考虑以下内容，我们将其称为&lt;strong&gt;原始优化问题&lt;/strong&gt;：&lt;/p&gt;
$$
\min_{w} \ f(w)
$$$$
\text{s.t.} \quad g_i(w) \le 0, \quad i = 1, \dots, k
$$$$
h_i(w) = 0, \quad i = 1, \dots, l
$$&lt;p&gt;为了解决这个问题，我们首先定义&lt;strong&gt;广义拉格朗日算子&lt;/strong&gt;：&lt;/p&gt;
$$
\mathcal{L}(w, \alpha, \beta)=
f(w)+
\sum_{i=1}^{k} \alpha_i g_i(w)+
\sum_{i=1}^{l} \beta_i h_i(w)
$$&lt;p&gt;这里，$\alpha_i$ 和 $\beta_i$ 是拉格朗日乘子。考虑&lt;/p&gt;
$$
\theta_P(w)=
\max_{\alpha, \beta : \alpha_i \ge 0}
\mathcal{L}(w, \alpha, \beta)
$$&lt;p&gt;这里，“$P$” 下标代表“原始”。假设给定某个 $w$。如果 $w$ 违反任何原始约束（即，对于某个 $i$，$g_i(w) &amp;gt; 0$ 或 $h_i(w) \neq 0$），那么可以验证&lt;/p&gt;
$$
\theta_P(w)=
\max_{\alpha, \beta : \alpha_i \ge 0}
\left(
f(w)+
\sum_{i=1}^{k} \alpha_i g_i(w)+
\sum_{i=1}^{l} \beta_i h_i(w)
\right)
\tag{1}
$$$$
= \infty
\tag{2}
$$&lt;p&gt;相反，如果对于特定的 $w$ 确实满足约束，则 $\theta_P(w) = f(w)$。因此，&lt;/p&gt;
$$
\theta_P(w)=
\begin{cases}
f(w) &amp; \text{如果 } w \text{ 满足原始约束} \\
\infty &amp; \text{其他}
\end{cases}
$$&lt;p&gt;因此，对于所有满足原始约束的 $w$，$\theta_P$ 与我们的问题中的目标具有相同的值，并且如果 $w$ 违反约束条件，那么 $\theta_P$ 为正无穷大。因此，如果我们考虑最小化问题&lt;/p&gt;
$$
\min_w \theta_P(w)=
\min_w \max_{\alpha,\beta:\alpha_i \ge 0} \mathcal{L}(w,\alpha,\beta)
$$&lt;p&gt;我们看到它与我们原始的原始问题是同一个问题（即具有相同的解）。为了以后的使用，我们还将目标的最优值定义为&lt;/p&gt;
$$
p' = \min_w \theta_P(w)
$$&lt;p&gt;我们称之为原始问题的值。&lt;/p&gt;
&lt;p&gt;现在，让我们看一个稍微不同的问题。我们定义&lt;/p&gt;
$$
\theta_D(\alpha,\beta)=
\min_w \mathcal{L}(w,\alpha,\beta)
$$&lt;p&gt;这里，下标 “$D$” 代表“对偶”。还要注意，在 $\theta_P$ 的定义中，我们关于 $\alpha,\beta$ 进行了优化（最大化），而这里是关于 $w$ 的最小化。&lt;/p&gt;
&lt;p&gt;我们现在可以提出对偶优化问题：&lt;/p&gt;
$$
\max_{\alpha,\beta:\alpha_i \ge 0} \theta_D(\alpha,\beta)=
\max_{\alpha,\beta:\alpha_i \ge 0} \min_w \mathcal{L}(w,\alpha,\beta)
$$&lt;p&gt;这与上面显示的原始问题完全相同，只是现在交换了 “max” 和 “min” 的顺序。我们还将对偶问题的目标的最优值定义为&lt;/p&gt;
$$
d' = \max_{\alpha,\beta:\alpha_i \ge 0} \theta_D(\alpha,\beta)
$$&lt;p&gt;原始和对偶问题之间有什么关系？很容易证明如下这一点：&lt;/p&gt;
$$
d'=
\max_{\alpha,\beta:\alpha_i \ge 0} \min_w \mathcal{L}(w,\alpha,\beta)
\le
\min_w \max_{\alpha,\beta:\alpha_i \ge 0} \mathcal{L}(w,\alpha,\beta)=
p'
$$&lt;p&gt;事实上，我们显然有&lt;/p&gt;
$$
\min_w \mathcal{L}(w,\alpha,\beta)
\le
\mathcal{L}(w,\alpha,\beta)
\le
\max_{\alpha,\beta:\alpha_i \ge 0} \mathcal{L}(w,\alpha,\beta)
$$&lt;p&gt;从而&lt;/p&gt;
$$
\min_w \mathcal{L}(w,\alpha,\beta)
\le
\min_w \max_{\alpha,\beta:\alpha_i \ge 0} \mathcal{L}(w,\alpha,\beta)=
p'
$$&lt;p&gt;并且&lt;/p&gt;
$$
d'=
\max_{\alpha,\beta:\alpha_i \ge 0} \min_w \mathcal{L}(w,\alpha,\beta)
\le
\min_w \max_{\alpha,\beta:\alpha_i \ge 0} \mathcal{L}(w,\alpha,\beta)=
p'
$$&lt;p&gt;但是，在某些条件下，我们会有&lt;/p&gt;
$$
d' = p'
$$&lt;p&gt;这样我们就可以解决对偶问题来代替原始问题。让我们看看这些条件是什么。&lt;/p&gt;
&lt;p&gt;假设 $f$ 和 $g_i$ 是凸函数（即 Hessian 矩阵是正定的），$h_i$ 是仿射函数（即 $h_i(w) = a_i^T w + b$）。进一步假设 $g_i$ 约束是（严格地）可行的；这意味着存在某个 $w$ 使得对所有的 $i$ 有 $g_i(w) &amp;lt; 0$。&lt;/p&gt;
&lt;p&gt;在我们的上述假设下，必将存在 $w&amp;rsquo;, \alpha&amp;rsquo;, \beta&amp;rsquo;$，使得 $w&amp;rsquo;$ 是原始问题的解，$\alpha&amp;rsquo;, \beta&amp;rsquo;$ 是对偶问题的解，而且&lt;/p&gt;
$$
p' = d' = \mathcal{L}(w', \alpha', \beta')
$$&lt;p&gt;此外，$w&amp;rsquo;, \alpha&amp;rsquo;, \beta&amp;rsquo;$ 满足 Karush-Kuhn-Tucker (KKT) 条件，如下：&lt;/p&gt;
$$
\frac{\partial}{\partial w_i} \mathcal{L}(w', \alpha', \beta') = 0,
\quad i = 1, \dots, n
\tag{3}
$$$$
\frac{\partial}{\partial \beta_i} \mathcal{L}(w', \alpha', \beta') = 0,
\quad i = 1, \dots, l
\tag{4}
$$$$
\alpha'_i g_i(w') = 0,
\quad i = 1, \dots, k
\tag{5}
$$$$
g_i(w') \le 0,
\quad i = 1, \dots, k
\tag{6}
$$$$
\alpha'_i \ge 0,
\quad i = 1, \dots, k
\tag{7}
$$&lt;p&gt;此外，如果某个 $w&amp;rsquo;, \alpha&amp;rsquo;, \beta&amp;rsquo;$ 满足 KKT 条件，那么它也是原始和对偶问题的解。&lt;/p&gt;
&lt;p&gt;我们注意方程 (5)，这被称为 &lt;strong&gt;KKT 对偶互补条件&lt;/strong&gt;。具体来说，它推出如果 $\alpha&amp;rsquo;_i &amp;gt; 0$，那么 $g_i(w&amp;rsquo;) = 0$。（即，“$g_i(w&amp;rsquo;) \le 0$” 约束是&lt;strong&gt;有效的&lt;/strong&gt;，这意味着它取等号而不是不等号。）稍后，这将是证明 SVM 只有少量“支持向量”的关键；当我们讨论 SMO 算法时，KKT 对偶互补条件也将为我们提供收敛性测试。&lt;/p&gt;
&lt;h3 id="最优间隔分类器-1"&gt;最优间隔分类器
&lt;/h3&gt;&lt;p&gt;之前，我们提出了以下（原始）优化问题来找到最优间隔分类器：&lt;/p&gt;
$$
\min_{w,b} \ \frac{1}{2}\|w\|^2
$$$$
\text{s.t.} \quad y^{(i)}(w^T x^{(i)} + b) \ge 1, \ i = 1, \dots, m
$$&lt;p&gt;我们可以将限制条件写成&lt;/p&gt;
$$
g_i(w) = -y^{(i)}(w^T x^{(i)} + b) + 1 \le 0
$$&lt;p&gt;我们对每个训练样本都有一个这样的约束。注意，根据 KKT 对偶互补条件，我们将仅对函数间隔等于 1 的训练样本具有 $\alpha_i &amp;gt; 0$（即对应于取等号的约束条件，$g_i(w) = 0$）。请看下图，其中实线表示具有最大间隔分离的超平面。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-7/p1.jpg"
width="493"
height="339"
srcset="https://lunatide.tech/p/cs229-lecture-7/p1_hu_23e88243116dffc.jpg 480w, https://lunatide.tech/p/cs229-lecture-7/p1_hu_bb1bfdf4d419014c.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
&gt;&lt;/p&gt;
&lt;p&gt;间距最小的点恰好是最接近决策边界的点；这里，这些点是平行于决策边界的虚线上三个点（一个负样本和两个正样本）。因此，在我们的优化问题的最优解中，只有三个 $\alpha_i$，即对应于这三个训练样本的 $\alpha_i$ 将是非零的。这三个点在这个问题中被称为&lt;strong&gt;支持向量&lt;/strong&gt;。支持向量的数量比训练集的大小小得多的事实将在以后有用。&lt;/p&gt;
&lt;p&gt;让我们继续。当我们推导问题的对偶形式时，需要注意的一个关键想法是我们将尝试仅根据内积 $\langle x^{(i)}, x^{(j)} \rangle$ 来编写算法（在输入特征空间中的点之间将其视为 $(x^{(i)})^T x^{(j)}$）。当我们应用内核技巧时，我们可以用这些内积来表达我们的算法，这一事实将非常关键。&lt;/p&gt;
&lt;p&gt;当我们为优化问题构造拉格朗日算子时，我们有：&lt;/p&gt;
$$
\mathcal{L}(w,\alpha,\beta)=
\frac{1}{2}\|w\|^2-
\sum_{i=1}^{m}
\alpha_i
\left[
y^{(i)}(w^T x^{(i)} + b) - 1
\right]
\tag{8}
$$&lt;p&gt;注意，只有 $\alpha_i$ 乘子而没有 $\beta_i$ 乘子，因为问题只有不等式约束。&lt;/p&gt;
&lt;p&gt;让我们找到问题的对偶形式。为此，我们需要首先关于 $w,b$ 最小化 $\mathcal{L}(w,\alpha,\beta)$（对于固定的 $\alpha_i$），从而得到 $\theta_D$。我们通过令 $\mathcal{L}$ 关于 $w$ 和 $b$ 的偏导数为零来做到这一点。我们有：&lt;/p&gt;
$$
\nabla_w \mathcal{L}(w,\alpha,\beta)=
w-
\sum_{i=1}^{m}
\alpha_i y^{(i)} x^{(i)}=
0
$$&lt;p&gt;这意味着&lt;/p&gt;
$$
w=
\sum_{i=1}^{m}
\alpha_i y^{(i)} x^{(i)}
\tag{9}
$$&lt;p&gt;关于 $b$ 的求导，我们得到&lt;/p&gt;
$$
\nabla_b \mathcal{L}(w,\alpha,\beta)=
\sum_{i=1}^{m}
\alpha_i y^{(i)}=
0
\tag{10}
$$&lt;p&gt;如果我们利用等式 (9) 中 $w$ 的定义并将其带入拉格朗日算子（等式 (8)），并简化，我们得到&lt;/p&gt;
$$
\mathcal{L}(w,\alpha,\beta)=
\sum_{i=1}^{m} \alpha_i-
\frac{1}{2}
\sum_{i=1}^{m}
\sum_{j=1}^{m}
y^{(i)} y^{(j)}
\alpha_i \alpha_j
(x^{(i)})^T x^{(j)}-
b \sum_{i=1}^{m} \alpha_i y^{(i)}
$$&lt;p&gt;但是根据公式 (10)，最后一项为 0，所以我们得到&lt;/p&gt;
$$
\mathcal{L}(w,\alpha,\beta)=
\sum_{i=1}^{m} \alpha_i-
\frac{1}{2}
\sum_{i=1}^{m}
\sum_{j=1}^{m}
y^{(i)} y^{(j)}
\alpha_i \alpha_j
(x^{(i)})^T x^{(j)}
$$&lt;p&gt;回想一下，通过关于 $w,b$ 最小化 $\mathcal{L}$，我们得到了上面的等式。将这与约束 $\alpha_i \ge 0$ 和约束 (10) 放在一起，我们得到以下对偶优化问题：&lt;/p&gt;
$$
\max_{\alpha}
\quad
W(\alpha)=
\sum_{i=1}^{m} \alpha_i-
\frac{1}{2}
\sum_{i=1}^{m}
\sum_{j=1}^{m}
y^{(i)} y^{(j)}
\alpha_i \alpha_j
\langle x^{(i)}, x^{(j)} \rangle
$$$$
\text{s.t.}
\quad
\alpha_i \ge 0,
\quad i = 1, \dots, m
$$$$
\sum_{i=1}^{m} \alpha_i y^{(i)} = 0
$$&lt;p&gt;不难验证在我们的优化问题中确实满足 $p&amp;rsquo; = d&amp;rsquo;$ 和 KKT 条件（等式 (3)–(7)）所需的条件。因此，我们可以解决对偶问题来代替解决原始问题。具体来说，在上面的对偶问题中，我们有一个最大化问题，其中参数是 $\alpha_i$。我们稍后将讨论我们将用于解决对偶问题的特定算法，但如果我们确实能够解决它（即在满足约束条件下找到最大化 $W(\alpha)$ 的 $\alpha$），然后我们可以使用等式 (9) 返回作为 $\alpha$ 的函数的最优 $w$。找到 $w&amp;rsquo;$ 后，通过考虑原始问题，找到截距项 $b$ 的最优值也是直截了当的：&lt;/p&gt;
$$
b'=-
\frac{
\max_{i: y^{(i)}=-1} {w'}^T x^{(i)}+
\min_{i: y^{(i)}=1} {w'}^T x^{(i)}
}{2}
\tag{11}
$$&lt;p&gt;事实上，对于 $\alpha_i \ne 0$，我们有&lt;/p&gt;
$$
g_i(w)=- y^{(i)}(w^T x^{(i)} + b) + 1=
0
$$&lt;p&gt;所以&lt;/p&gt;
$$
y^{(i)}(w^T x^{(i)} + b) = 1
\quad \Longrightarrow \quad
w^T x^{(i)} + b = y^{(i)}
\quad \Longrightarrow \quad
b = y^{(i)} - w^T x^{(i)}
$$&lt;p&gt;注意到&lt;/p&gt;
$$
g_i(w)=- y^{(i)}(w^T x^{(i)} + b) + 1 \le 0
\quad \Longleftrightarrow \quad
y^{(i)}(w^T x^{(i)} + b) \ge 1
$$&lt;p&gt;如果 $y^{(i)} = 1$，那么&lt;/p&gt;
$$
w^T x^{(i)} + b \ge 1
$$&lt;p&gt;如果 $y^{(i)} = -1$，那么&lt;/p&gt;
$$
w^T x^{(i)} + b \le -1
$$&lt;p&gt;从而满足&lt;/p&gt;
$$
g_i(w)=- y^{(i)}(w^T x^{(i)} + b) + 1=
0
$$&lt;p&gt;的点必然为&lt;/p&gt;
$$
\arg \min_{i: y^{(i)}=1} w^T x^{(i)},
\qquad
\arg \max_{i: y^{(i)}=-1} w^T x^{(i)}
$$&lt;p&gt;结合之前的式子以及最优的 $w$ 为 $w&amp;rsquo;$ 可得&lt;/p&gt;
$$
b=
1-
\min_{i: y^{(i)}=1} {w'}^T x^{(i)}=-1-
\max_{i: y^{(i)}=-1} {w'}^T x^{(i)}
$$&lt;p&gt;两式相加可得&lt;/p&gt;
$$
b'=-
\frac{
\max_{i: y^{(i)}=-1} {w'}^T x^{(i)}+
\min_{i: y^{(i)}=1} {w'}^T x^{(i)}
}{2}
$$&lt;p&gt;
在继续之前，让我们更仔细地看一下等式 (9)，它给出了 $w$ 的最佳值（$\alpha$ 的最佳值）。假设我们已经将模型的参数拟合到训练集，现在希望在新的输入 $x$ 处进行预测。我们将计算 $w^T x + b$，并且当且仅当该项大于零时才预测 $y = 1$。但是使用 (9)，这项也可以写成：&lt;/p&gt;
$$
\begin{align}
w^T x + b&amp;=
\left(
\sum_{i=1}^{m}
\alpha_i y^{(i)} x^{(i)}
\right)^T x+ b
\tag{12}
\\&amp;=
\sum_{i=1}^{m}
\alpha_i y^{(i)}
\langle x^{(i)}, x \rangle+ b
\tag{13}
\end{align}
$$&lt;p&gt;
因此，如果我们找到 $\alpha_i$，为了进行预测，我们必须计算仅取决于 $x$ 与训练集中的点之间的内积。此外，我们之前看到除了支持向量之外，$\alpha_i$ 都将为零。因此，上述求和中的许多项将为零，并且我们确实只需要找到 $x$ 和支持向量之间的内积（通常只有一小部分）就能计算 (13) 并进行预测。&lt;/p&gt;
&lt;p&gt;通过讨论优化问题的对偶形式，我们获得了对问题结构的重要洞察，并且还能够仅根据输入特征向量之间的内积来编写整个算法。在下一节中，我们将利用属性核方法应用于我们的分类问题。由此产生的算法，&lt;strong&gt;支持向量机&lt;/strong&gt;，将能够在非常高维空间中有效地学习。&lt;/p&gt;</description></item><item><title>CS229 Lecture 6</title><link>https://lunatide.tech/p/cs229-lecture-6/</link><pubDate>Fri, 20 Feb 2026 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-6/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-6/pic1.jpg" alt="Featured image of post CS229 Lecture 6" /&gt;&lt;h3 id="针对文本分类的事件模型"&gt;针对文本分类的事件模型
&lt;/h3&gt;&lt;p&gt;接下里用一个文本分类方面的模型来对生成学习算法进行收尾，之前说的朴素贝叶斯方法已经可以解决很多分类问题了，不过还有另外一个算法在针对文本的分类效果要更好&lt;/p&gt;
&lt;p&gt;在文本分类的特定上下文中，朴素贝叶斯使用了所谓的 &lt;strong&gt;多变量伯努利事件模型&lt;/strong&gt;。在这个模型中，我们假设生成电子邮件的方式是首先随机确定(根据类先验$p(y)$) 邮件是垃圾邮件还是非垃圾邮件，然后发送邮件的人通过字典根据概率$p(x_i = 1 \mid y)$ 独立决定是否包括邮件中的每个单词。因此，邮件的概率由&lt;br&gt;
&lt;/p&gt;
$$
p(y)\prod_{i=1}^{n} p(x_i \mid y)
$$&lt;p&gt;
给出。&lt;/p&gt;
&lt;p&gt;这里有个不同的模型，称为&lt;strong&gt;多项事件模型&lt;/strong&gt;。为了描述这个模型，我们将使用不同的表示法和一组特征来表示电子邮件。我们令 $x_i$ 表示电子邮件中第 $i$ 个单词的标识。因此，$x_i$ 现在是一个整数，取值为 ${1, \dots, |V|}$，其中 $|V|$ 是我们词汇量的大小（字典）。$n$ 个单词的电子邮件现在由长度为 $n$ 的向量 $(x_1, x_2, \dots, x_n)$ 表示；请注意，$n$ 可能因不同文档而异。例如，如果电子邮件以 “A NIPS …” 开头，那么 $x_1 = 1$（“a” 是字典中的第 1 个单词），$x_2 = 35000$（如果 “nips” 是字典中的第 35000 个单词）。&lt;/p&gt;
&lt;p&gt;在多项事件模型中，我们假设生成电子邮件的方式是通过如下随机过程：首先确定邮件是垃圾邮件/非垃圾邮件（根据 $p(y)$）。然后，电子邮件的发件人首先从某个多项分布生成 $x_1$（$p(x_1 \mid y)$）。接下来，第二个单词 $x_2$ 独立于 $x_1$ 且从相同的多项分布中选择，并且类似地对于 $x_3, x_4$ 等等，直到已经生成了电子邮件的所有 $n$ 个单词。因此，邮件的总概率由&lt;br&gt;
&lt;/p&gt;
$$
p(y)\prod_{i=1}^{n} p(x_i \mid y)
$$&lt;p&gt;
给出。请注意，此公式看起来与我们之前在多变量伯努利事件模型下的邮件概率公式类似，但公式中的项现在意味着非常不同的事物。特别是 $x_j \mid y$ 现在服从多项分布，而不是伯努利分布。&lt;/p&gt;
&lt;p&gt;我们的新模型的参数如前所述是 $\phi_y = p(y)$，$\phi_{k \mid y=1} = p(x_j = k \mid y = 1)$（对于任何 $j$），以及 $\phi_{k \mid y=0} = p(x_j = k \mid y = 0)$。注意，我们假设 $p(x_j \mid y)$ 对于 $j$ 的所有值是相同的（即，生成单词的分布不依赖于其在电子邮件中的位置 $j$）。&lt;/p&gt;
&lt;p&gt;如果给定训练集 ${(x^{(i)}, y^{(i)}); i = 1, \dots, m}$，其中\(x^{(i)} = (x^{(i)}_1, x^{(i)}_2, \dots, x^{(i)}_{n_i})\)（这里，$n_i$ 是第 $i$ 个训练样本的单词数），数据的似然性由下式给出：
&lt;/p&gt;
$$
\mathcal{L}(\phi_y, \phi_{k \mid y=0}, \phi_{k \mid y=1})=
\prod_{i=1}^{m} p(x^{(i)}, y^{(i)})=
\prod_{i=1}^{m}
\left(
\prod_{j=1}^{n_i} p(x^{(i)}_j \mid y^{(i)}; \phi_{k \mid y=0}, \phi_{k \mid y=1})
\right)p(y^{(i)}; \phi_y)
$$&lt;p&gt;最大化上式会产生参数的最大似然估计：&lt;/p&gt;
$$
\phi_{k \mid y=1}=\frac{\sum_{i=1}^{m} \sum_{j=1}^{n_i} \mathbf{1}\{x^{(i)}_j = k \land y^{(i)} = 1\}}{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\} n_i}
$$$$
\phi_{k \mid y=0}=\frac
{\sum_{i=1}^{m} \sum_{j=1}^{n_i} \mathbf{1}\{x^{(i)}_j = k \land y^{(i)} = 0\}}
{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\} n_i}
$$$$
\phi_y=\frac
{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}}
{m}
$$&lt;p&gt;如果我们在估计 $\phi_{k \mid y=1}$ 和 $\phi_{k \mid y=0}$ 时应用拉普拉斯平滑，我们对分子加 1，对分母加 $|V|$，并得到：&lt;/p&gt;
$$
\phi_{k \mid y=1}=
\frac{
\sum_{i=1}^{m} \sum_{j=1}^{n_i}
\mathbf{1}\{x^{(i)}_j = k \land y^{(i)} = 1+ 1
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1+ |V|
}
$$$$
\phi_{k \mid y=0}=
\frac{
\sum_{i=1}^{m} \sum_{j=1}^{n_i}
\mathbf{1}\{x^{(i)}_j = k \land y^{(i)} = 0\}+ 1
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\} n_i + |V|
}
$$&lt;p&gt;虽然不一定是最好的分类算法，但朴素贝叶斯分类器通常效果非常好。考虑到它的简单性和易于实现，它通常也非常适合作为第一个尝试。&lt;/p&gt;
&lt;h3 id="支持向量机"&gt;支持向量机
&lt;/h3&gt;&lt;p&gt;这一章节主要讲的是&lt;strong&gt;支持向量机(SVM)学习算法&lt;/strong&gt;，SVM是现成的最好的监督学习算法。为了讲述SVM，我们首先需要讨论间隔以及将数据以大的“间隔”分开的想法。接下来，我们将讨论最优间隔分类器，这将引导我们对拉格朗日对偶的讨论。我们还将看到核方法，它提供了一种在非常高维（例如无限维）特征空间中有效应用SVM的方法，最后，我们会使用SMO算法结束这章，该方法可以有效地实现支持向量机&lt;/p&gt;
&lt;h4 id="边界直觉"&gt;边界：直觉
&lt;/h4&gt;&lt;p&gt;我们将通过讨论间隔来开始我们关于SVM的讨论。本节将给出关于间隔和我们预测的“信心”的直觉；这些想法将在第3节中正式提出。&lt;/p&gt;
&lt;p&gt;考虑logistic回归，其中概率 $p(y = 1 \mid x; \theta)$ 由 $h_\theta(x) = g(\theta^T x)$ 建模。然后，当且仅当 $h_\theta(x) \ge 0.5$ 时，我们才会预测输入 $x$ 为“1”，或者等价的，当且仅当 $\theta^T x \ge 0$。&lt;/p&gt;
&lt;p&gt;考虑一个正训练样本 $(y = 1)$。$\theta^T x$ 越大，$h_\theta(x) = p(y = 1 \mid x; w, b)$ 也越大，因此标记为1的“置信度”也越高。因此，非正式地，我们可以对 $y = 1$ 进行非常自信的预测，如果 $\theta^T x \gg 0$。类似地，我们将logistic回归视为对 $y = 0$ 进行非常自信的预测，如果 $\theta^T x \ll 0$。&lt;/p&gt;
&lt;p&gt;给定一个训练集，再次非正式地看起来我们已经找到了一个对训练数据很好的拟合，如果我们可以找到 $\theta$，以便每当 $y^{(i)} = 1$ 时，$\theta^T x^{(i)} \gg 0$，并且每当 $y^{(i)} = 0$ 时，$\theta^T x^{(i)} \ll 0$，因为这将反映所有训练样本的非常有信心（和正确）的分类。这似乎是一个很好的目标，我们很快就会使用函数间隔的概念来形式化这个想法。&lt;/p&gt;
&lt;p&gt;对于不同的直觉，请考虑下图，其中 x 代表正训练样本，o 代表负训练样本。决策边界（这是由等式 $\theta^T x = 0$ 给出的线，也称为&lt;strong&gt;分离超平面&lt;/strong&gt;）也在图中，并且三个点也被标记为 A、B 和 C。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-6/p1.jpg"
width="428"
height="330"
srcset="https://lunatide.tech/p/cs229-lecture-6/p1_hu_aa6a43531a60774f.jpg 480w, https://lunatide.tech/p/cs229-lecture-6/p1_hu_4f137f80d66a21b5.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="311px"
&gt;&lt;/p&gt;
&lt;p&gt;注意到A点离决策边界很远。如果我们被要求在A处对 $y$ 的值进行预测，那么我们应该非常确信 $y = 1$。相反，C点非常接近决策边界，虽然它位于我们预测 $y = 1$ 的决策边界的一侧，但似乎只是对决策边界的一个小变化很容易导致我们的预测改变为 $y = 0$。因此，我们对A处的预测比对C的预测更有信心。B点位于这两种情况之间，更广泛地说，我们看到如果一点远离分离超平面，那么我们对预测可能会更有信心。&lt;/p&gt;
&lt;p&gt;同样，非正式地，我们认为，如果给定一个训练集，我们设法找到一个决策边界，使我们能够在训练样例上做出所有正确和自信（意味着远离决策边界）的预测，那将是非常好的。我们稍后将使用几何间隔的概念将其形式化。&lt;/p&gt;
&lt;h4 id="符号"&gt;符号
&lt;/h4&gt;&lt;p&gt;为了使我们对SVM的讨论更容易，我们首先需要引入一个新的符号来讨论分类。我们将考虑用于解决带有标签 $y$ 和特征 $x$ 的二元分类问题的线性分类器。从现在开始，我们将使用 $y \in {-1, 1}$（而不是 ${0, 1}$）来表示类标签。此外，我们将使用参数 $w, b$，而不是使用向量 $\theta$ 来参数化我们的线性分类器，并将分类器改写为&lt;/p&gt;
$$
h_{w,b}(x) = g(w^T x + b)
$$&lt;p&gt;这里，如果 $z \ge 0$，则 $g(z) = 1$，否则 $g(z) = -1$。这个 “$w, b$” 表示法允许我们明确地将截距项 $b$ 与其他参数分开处理。（我们也放弃了以前让 $x_0 = 1$ 成为输入特征向量中的额外坐标的约定。）因此，$b$ 扮演以前 $\theta_0$ 的角色，$w$ 扮演 $(\theta_1, \dots, \theta_n)^T$ 的角色。&lt;/p&gt;
&lt;p&gt;还要注意，根据我们上面对 $g$ 的定义，我们的分类器将直接预测 $1$ 或 $-1$（参见感知机算法），而不是首先进行估计 $y$ 为 $1$ 的概率的中间步骤（这是 logistic 回归所做的）。&lt;/p&gt;
&lt;h4 id="函数和几何间隔"&gt;函数和几何间隔
&lt;/h4&gt;&lt;p&gt;让我们形式化函数间隔和几何间隔的概念。给定一个训练样本 $(x^{(i)}, y^{(i)})$，我们根据训练样本定义 $(w,b)$ 的&lt;strong&gt;函数间隔&lt;/strong&gt;为&lt;/p&gt;
$$
\hat{\gamma}^{(i)} = y^{(i)} (w^T x^{(i)} + b)
$$&lt;p&gt;注意，如果 $y^{(i)} = 1$，那么为了使函数间隔变大（即，为了使我们的预测有信心和正确），我们需要 $w^T x^{(i)} + b$ 为大的正数。相反，如果 $y^{(i)} = -1$，那么为了使函数间隔变大，我们需要 $w^T x^{(i)} + b$ 为（绝对值）大的负数。此外，如果 $y^{(i)} (w^T x^{(i)} + b) &amp;gt; 0$，那么我们对这个例子的预测是正确的。因此，大的函数间隔代表了自信和正确的预测。&lt;/p&gt;
&lt;p&gt;对于上面给出的线性分类器 $g$（取 ${-1,1}$ 中的值），函数间隔的一个属性使得它不是一个非常好的置信度量。给定我们的选择 $g$，我们注意到如果我们用 $2w$ 代替 $w$，用 $2b$ 代替 $b$，那么因为&lt;/p&gt;
$$
g(w^T x + b) = g(2w^T x + 2b)
$$&lt;p&gt;所以这根本不会改变 $h_{w,b}(x)$。即，$g$，因此也是 $h_{w,b}(x)$，仅取决于 $w^T x + b$ 的符号，而不取决于其模长。然而，用 $(2w, 2b)$ 代替 $(w, b)$ 也会导致我们的函数间隔乘以 2。因此，通过利用对 $w$ 和 $b$ 的缩放，我们可以使函数间隔任意大，但实际上没有改变任何有意义的事情，因此强制某种归一化条件可能是有意义的，例如 $|w|_2 = 1$；也就是说，我们可以用 $(w/|w|_2, b/|w|_2)$ 代替 $(w, b)$，然后考虑 $(w/|w|_2, b/|w|_2)$ 的函数间隔。&lt;/p&gt;
&lt;p&gt;给定训练集&lt;/p&gt;
$$
S = \{(x^{(i)}, y^{(i)}); i = 1, \dots, m\}
$$&lt;p&gt;我们还将 $(w,b)$ 关于 $S$ 的函数间隔定义为训练样本中最小的函数间隔，用 $\hat{\gamma}$ 表示，因此可以写成：&lt;/p&gt;
$$
\hat{\gamma} = \min_{i=1,\dots,m} \hat{\gamma}^{(i)}
$$&lt;p&gt;接下来，我们来谈谈&lt;strong&gt;几何间隔&lt;/strong&gt;。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-6/p2.jpg"
width="388"
height="282"
srcset="https://lunatide.tech/p/cs229-lecture-6/p2_hu_61ca2fb55350e50e.jpg 480w, https://lunatide.tech/p/cs229-lecture-6/p2_hu_ecdc56822db7d5a1.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
&gt;&lt;/p&gt;
&lt;p&gt;上图展示了对应于 $(w,b)$ 的决策边界以及向量 $w$。注意，$w$ 与分离超平面正交。考虑 A 处的点，它代表某个训练样本 $x^{(i)}$，标签为 $y^{(i)} = 1$，它与决策边界的距离为 $\gamma^{(i)}$，由线段 $AB$ 给出。&lt;/p&gt;
&lt;p&gt;我们怎样才能得到 $\gamma^{(i)}$ 的值？注意到 $w/|w|$ 是和 $w$ 同向的单位长度向量。由于 A 代表 $x^{(i)}$，因此我们发现点 $B$ 由&lt;/p&gt;
$$
x^{(i)} - \gamma^{(i)} \frac{w}{\|w\|}
$$&lt;p&gt;给出。但这一点在决策边界上，决策边界上的所有点 $x$ 都满足方程 $w^T x + b = 0$。因此，&lt;/p&gt;
$$
w^T \left( x^{(i)} - \gamma^{(i)} \frac{w}{\|w\|} \right) + b = 0
$$&lt;p&gt;解出 $\gamma^{(i)}$ 得到&lt;/p&gt;
$$
\gamma^{(i)}=
\frac{w^T x^{(i)} + b}{\|w\|}=
\left( \frac{w}{\|w\|} \right)^T x^{(i)} + \frac{b}{\|w\|}
$$&lt;p&gt;这是针对图中 A 处的正训练样本的情况得到的，其中处于决策边界的“正”侧是好的。更一般地，我们定义 $(w,b)$ 相对于训练样本 $(x^{(i)}, y^{(i)})$ 的几何间隔为&lt;/p&gt;
$$
\gamma^{(i)}=
y^{(i)} \left(
\left( \frac{w}{\|w\|} \right)^T x^{(i)} + \frac{b}{\|w\|}
\right)
$$&lt;p&gt;请注意，如果 $|w| = 1$，那么函数间隔等于几何间隔——这就为我们提供了一种方法来联系这两种不同的间隔概念。此外，几何间隔对于重新缩放参数是不变的；即，如果我们用 $2w$ 代替 $w$，用 $2b$ 代替 $b$，则几何间隔不会改变。事实上，这将在以后派上用场。具体来说，由于这种参数缩放的不变性，当试图将 $w$ 和 $b$ 拟合到训练数据时，我们可以对 $w$ 施加任意缩放约束而不改变任何重要的东西；例如，我们可以要求 $|w| = 1$，或 $|w|_1 = 5$，或 $|w_1 + b| + |w_2| = 2$，只需重新调整 $w$ 和 $b$ 即可满足其中任何一个。&lt;/p&gt;
&lt;p&gt;给定训练集&lt;/p&gt;
$$
S = \{(x^{(i)}, y^{(i)}); i = 1, \dots, m\}
$$&lt;p&gt;我们还将 $(w,b)$ 关于 $S$ 的几何间隔定义为训练样本中最小的几何间隔，用 $\gamma$ 表示，因此可以写成：&lt;/p&gt;
$$
\gamma = \min_{i=1,\dots,m} \gamma^{(i)}
$$</description></item><item><title>CS229 Lecture 5(2)</title><link>https://lunatide.tech/p/cs229-lecture-52/</link><pubDate>Thu, 22 Jan 2026 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-52/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-52/pic1.jpg" alt="Featured image of post CS229 Lecture 5(2)" /&gt;&lt;h3 id="朴素贝叶斯"&gt;朴素贝叶斯
&lt;/h3&gt;&lt;p&gt;在GDA中，特征向量x是连续的值为实数的向量。下面我们要讲的是当 \(x_i\) 是离散的时候所使用的另一种学习算法。&lt;/p&gt;
&lt;p&gt;下面就来看一个样例，来尝试建立一个邮件筛选器，使用机器学习的方法。这回咱们要来对邮件信息进行分类，来判断是否为商业广告邮件还是非垃圾邮件。在学会了怎么实现之后，我们就可以让邮件阅读器能够自动对垃圾信息进行过滤，或者单独把这些垃圾邮件放进一个单独的文件夹中。对邮件进行分类是一个案例，属于文本分类这一更广泛问题集合。&lt;/p&gt;
&lt;p&gt;假设我们有了一个训练集（也就是一堆已经标好了是否为垃圾邮件的邮件）。要构建垃圾邮件分类器，咱们先要开始确定用来描述一封邮件的特征 \(x_i\) 有哪些。&lt;/p&gt;
&lt;p&gt;我们将用一个特征向量来表示一封邮件，这个向量的长度等于字典中单词的个数。如果邮件中包含了字典中的第 \(i\) 个单词，那么令$x_i = 1$，反之则$x_i = 0$。例如:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-52/p1.jpg"
width="369"
height="262"
srcset="https://lunatide.tech/p/cs229-lecture-52/p1_hu_24d2c244daf379eb.jpg 480w, https://lunatide.tech/p/cs229-lecture-52/p1_hu_781b30d3469ce0de.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="338px"
&gt;&lt;/p&gt;
&lt;p&gt;就用来表示一个邮件，其中包含了两个单词 “a” 和 “buy”，但没有单词 “aardvark”、“aardwolf” 或者 “zymurgy”。这个单词集合编码整理成的特征向量也成为词汇表，所以特征向量 x 的维度就等于词汇表的长度。&lt;/p&gt;
&lt;p&gt;选好了特征向量了，接下来就是建立一个生成模型。所以我们必须对 $p(x \mid y)$ 进行建模。但是，假如我们的单词有五万个词，则特征向量 $x \in {0, 1}^{50000}$（即 $x$ 是一个 50000 维的向量，其值是 0 或者 1），如果我们要对这样的 $x$ 进行多项式分布的建模，那么就可能有 $2^{50000}$ 种可能的输出，然后就要用一个 $(2^{50000} - 1)$ 维的参数向量。这样参数明显太多了。&lt;/p&gt;
&lt;p&gt;要给 $p(x \mid y)$ 建模，先来做一个非常强的假设。我们假设特征向量 $x_i$ 对于给定的 $y$ 是独立的。这个假设也叫做&lt;strong&gt;朴素贝叶斯假设&lt;/strong&gt;，基于此假设衍生的算法也就叫做&lt;strong&gt;朴素贝叶斯分类器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，如果 $y = 1$ 意味着一个邮件是垃圾邮件；然后其中 “buy” 是第2087个单词，而 “price” 是第39831个单词；那么接下来我们就假设，如果我告诉你 $y = 1$，也就是说某一个特定的邮件是垃圾邮件，那么对于 $x_{2087}$（也就是单词 buy 是否出现在邮件里）的了解并不会影响你对 $x_{39831}$（单词 price 出现的位置）的采信值。更正规一点，可以写成 $p(x_{2087} \mid y) = p(x_{2087} \mid y, x_{39831})$。（要注意这个并不是说 $x_{2087}$ 和 $x_{39831}$ 这两个特征是独立的，那样就变成了$p(X_{2087})=p(x_{2087} \mid x_{39831})$，相反，我们只假设$x_{2087}$和$x_{39831}$关于$y$条件独立）&lt;/p&gt;
&lt;p&gt;我们现在有：&lt;/p&gt;
$$
\begin{array}{lcl}
p(x_1, \ldots, x_{50000} \mid y)
&amp; = &amp; p(x_1 \mid y)\, p(x_2 \mid y, x_1)\, p(x_3 \mid y, x_1, x_2)\, \ldots \, p(x_{50000} \mid y, x_1, \ldots, x_{49999}) \\
&amp; = &amp; p(x_1 \mid y)\, p(x_2 \mid y)\, p(x_3 \mid y)\, \ldots \, p(x_{50000} \mid y) \\
&amp; = &amp; \prod_{i=1}^{n} p(x_i \mid y)
\end{array}
$$&lt;p&gt;
第一个等式简单地遵循概率的通用属性，第二个等式使用 NB 假设。我们注意到，即使朴素贝叶斯假设是一个非常强的假设，所得的算法在许多问题上也能很好地工作。&lt;/p&gt;
&lt;p&gt;我们的模型通过$\phi_{j \mid y=1} = p(x_j = 1 \mid y = 1), \phi_{j \mid y=0} = p(x_j = 1 \mid y = 0)$，以及$\phi_y = p(y = 1)$来参数化。像往常一样，给定训练集${(x^{(i)}, y^{(i)}); i = 1, \ldots, m}$，数据的似然性为：
&lt;/p&gt;
$$
\mathcal{L}(\phi_y, \phi_{j \mid y=0}, \phi_{j \mid y=1})
= \prod_{i=1}^{m} p(x^{(i)}, y^{(i)})
$$&lt;p&gt;关于 $\phi_y, \phi_{j \mid y=0}, \phi_{j \mid y=1}$ 最大化上述给出最大似然估计：&lt;/p&gt;
$$
\phi_{j \mid y=1}
= \frac{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1 \wedge x_j^{(i)} = 1\}}
{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}}
$$$$
\phi_{j \mid y=0}
= \frac{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0 \wedge x_j^{(i)} = 1\}}
{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\}}
$$$$
\phi_y
= \frac{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}}{m}
$$&lt;p&gt;证明如下：&lt;/p&gt;
&lt;p&gt;不难看出&lt;/p&gt;
$$
\begin{array}{rcl}
p(y) &amp; = &amp; (\phi_y)^y (1 - \phi_y)^{1-y}
\end{array}
$$$$
\begin{array}{rcl}
p(x \mid y = k) &amp; = &amp; \prod_{j=1}^{n} (\phi_{j \mid y = k})^{x_j}
(1 - \phi_{j \mid y = k})^{1-x_j}
\end{array}
$$&lt;p&gt;令 $\varphi$ 表示参数集&lt;br&gt;
${\phi_y, \phi_{j \mid y=0}, \phi_{j \mid y=1}, j = 1, \ldots, n}$，&lt;br&gt;
所以对数似然函数 $\ell(\varphi)$ 为&lt;/p&gt;
$$
\begin{array}{rcl}
\ell(\varphi)&amp; = &amp; \log \prod_{i=1}^{m} p(x^{(i)}, y^{(i)}; \varphi) \\&amp; = &amp; \sum_{i=1}^{m} \log p(x^{(i)}, y^{(i)}; \varphi) \\&amp; = &amp; \sum_{i=1}^{m} \log \big( p(x^{(i)} \mid y^{(i)}) p(y^{(i)}) \big) \\&amp; = &amp; \sum_{i=1}^{m} \log
\prod_{j=1}^{n}
(\phi_{j \mid y=y^{(i)}})^{x_j^{(i)}}
(1 - \phi_{j \mid y=y^{(i)}})^{1-x_j^{(i)}}
(\phi_y)^{y^{(i)}}
(1 - \phi_y)^{1-y^{(i)}} \\&amp; = &amp; \sum_{i=1}^{m} \sum_{j=1}^{n}
\Big(
x_j^{(i)} \log(\phi_{j \mid y=y^{(i)}})+ (1 - x_j^{(i)}) \log(1 - \phi_{j \mid y=y^{(i)}})
\Big) + \sum_{i=1}^{m}
\Big(
y^{(i)} \log \phi_y+ (1 - y^{(i)}) \log(1 - \phi_y)
\Big)
\end{array}
$$&lt;p&gt;先关于 $\phi_{j \mid y=k}$ 求梯度&lt;/p&gt;
$$
\begin{array}{lcl}
\nabla_{\phi_{j \mid y=k}} \ell(\varphi)&amp; = &amp; \sum_{i=1}^{m}
\Big(
x_j^{(i)} \frac{1}{\phi_{j \mid y=y^{(i)}}} \mathbf{1}\{y^{(i)} = k\}+ (1 - x_j^{(i)}) \frac{1}{1 - \phi_{j \mid y=y^{(i)}}} (-1)\mathbf{1}\{y^{(i)} = k\}
\Big) \\&amp; = &amp; \sum_{i=1}^{m}
\frac{\mathbf{1}\{y^{(i)} = k\}}
{\phi_{j \mid y=y^{(i)}} (1 - \phi_{j \mid y=y^{(i)}})}
\Big(
x_j^{(i)} (1 - \phi_{j \mid y=y^{(i)}})- (1 - x_j^{(i)}) \phi_{j \mid y=y^{(i)}}
\Big) \\&amp; = &amp; \frac{1}{\phi_{j \mid y=k} (1 - \phi_{j \mid y=k})}
\sum_{i=1}^{m}
\mathbf{1}\{y^{(i)} = k\}
\Big(
x_j^{(i)} - \phi_{j \mid y=k}
\Big)
\end{array}
$$&lt;p&gt;
令上式为0可得
&lt;/p&gt;
$$
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k\}
\big(x_j^{(i)} - \phi_{j \mid y=k}\big)= 0
\;\Rightarrow\;
\left(\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k\}\right)\phi_{j \mid y=k}= \sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k\} x_j^{(i)}= \sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k \wedge x_j^{(i)} = 1\}
\;\Rightarrow\;
\phi_{j \mid y=k}=
\frac{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k \wedge x_j^{(i)} = 1\}
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = k\}
}
$$&lt;p&gt;
从而&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_{j \mid y=0}
&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0 \wedge x_j^{(i)} = 1\}
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\}
}
\qquad
\phi_{j \mid y=1}
&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1 \wedge x_j^{(i)} = 1\}
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}
}
\end{array}
$$&lt;p&gt;关于 $\phi_y$ 求梯度可得&lt;/p&gt;
$$
\begin{array}{lcl}
\nabla_{\phi_y} \ell(\varphi)&amp; = &amp;
\displaystyle
\sum_{i=1}^{m}
\nabla_{\phi_y}
\Big(
y^{(i)} \log \phi_y+ (1 - y^{(i)}) \log(1 - \phi_y)
\Big) \\&amp; = &amp;
\displaystyle
\sum_{i=1}^{m}
\left(
y^{(i)} \frac{1}{\phi_y}- (1 - y^{(i)}) \frac{1}{1 - \phi_y}
\right) \\&amp; = &amp;
\displaystyle
\frac{1}{\phi_y (1 - \phi_y)}
\sum_{i=1}^{m}
\Big(
y^{(i)} (1 - \phi_y)- (1 - y^{(i)}) \phi_y
\Big) \\&amp; = &amp;
\displaystyle
\frac{1}{\phi_y (1 - \phi_y)}
\sum_{i=1}^{m}
\big(
y^{(i)} - \phi_y
\big)
\end{array}
$$&lt;p&gt;令上式为 $0$ 可得&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_y
&amp; = &amp;
\displaystyle
\frac{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}}{m}
\end{array}
$$&lt;p&gt;在上面的等式中，“$\wedge$”符号表示 “and”。这些参数具有非常自然的解释。例如，$\phi_{j \mid y=1}$ 是单词 $j$ 出现在垃圾邮件（$y = 1$）中的比例。在拟合了所有这些参数之后，为了对具有特征 $x$ 的新样本进行预测，我们就可以简单地进行计算&lt;/p&gt;
$$
\begin{array}{lcl}
p(y = 1 \mid x)&amp; = &amp;
\displaystyle
\frac{p(x \mid y = 1) p(y = 1)}{p(x)}\\&amp; = &amp;
\displaystyle
\frac{
\left( \prod_{i=1}^{n} p(x_i \mid y = 1) \right) p(y = 1)
}{
\left( \prod_{i=1}^{n} p(x_i \mid y = 1) \right) p(y = 1)+
\left( \prod_{i=1}^{n} p(x_i \mid y = 0) \right) p(y = 0)
}
\end{array}
$$&lt;p&gt;并选择具有较高后验概率的类别。&lt;/p&gt;
&lt;p&gt;最后，我们注意到虽然我们已经开发了朴素贝叶斯算法，主要是针对特征 $x_i$ 是二值的问题，将其推广到 $x_i$ 可以取 ${1,2,\ldots,k_i}$ 很简单。在这里，我们只是将 $p(x_i \mid y)$ 建模为多项分布而不是伯努利分布。实际上，即使某些原始输入属性（例如，房屋的生活区域，如我们之前的示例中）是连续值，将其离散化也是很常见的，即将其转换为一小组离散值，然后应用朴素贝叶斯。例如，如果我们使用某些特征 $x_i$ 来表示生活区域，我们可以将连续值离散化如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Living area (sq. feet)&lt;/th&gt;
&lt;th&gt;&amp;lt; 400&lt;/th&gt;
&lt;th&gt;400–800&lt;/th&gt;
&lt;th&gt;800–1200&lt;/th&gt;
&lt;th&gt;1200–1600&lt;/th&gt;
&lt;th&gt;&amp;gt; 1600&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$x_i$&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此，对于居住面积为890平方英尺的房屋，我们将相应特征 $x_i$ 的值设置为 3然后我们可以应用朴素贝叶斯算法，并使用多项分布对 $p(x_i \mid y)$ 建模，如前所述。当原始的连续值属性没有通过多元正态分布很好地建模时，
对特征进行离散化并使用朴素贝叶斯（而不是 GDA）通常会产生更好的分类器。&lt;/p&gt;
&lt;h3 id="拉普拉斯平滑"&gt;拉普拉斯平滑
&lt;/h3&gt;&lt;p&gt;我们已经描述过的朴素贝叶斯算法可以很好地解决许多问题，但是有一个简单的改变可以使它更好地工作，特别是对于文本分类。让我们简要讨论当前形式的算法问题，然后讨论我们如何解决它。&lt;/p&gt;
&lt;p&gt;考虑垃圾邮件/电子邮件分类，让我们假设，在完成 CS229 并完成项目的优秀工作后，您决定在 2003 年 6 月左右将您所做的工作提交给 NIPS 会议进行发布因为您最终在电子邮件中讨论会议，所以您也开始收到带有 “nips” 字样的消息。但这是你的第一篇 NIPS 论文，直到这个时候，你还没有看到任何包含 “nips” 这个词的电子邮件；特别是 “nips” 并没有出现在你的垃圾邮件/非垃圾邮件的训练集中。假设 “nips” 是字典中的第 35000 个单词，那么你的朴素贝叶斯垃圾邮件过滤器已经选择了参数$\phi_{35000 \mid y}$ 的最大似然估计值：&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_{35000 \mid y=1}&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{x_{35000}^{(i)} \wedge y^{(i)} = 1\}
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\}
}
= 0\\
\phi_{35000 \mid y=0}&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{x_{35000}^{(i)} \wedge y^{(i)} = 0\}
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\}
}= 0
\end{array}
$$&lt;p&gt;即，因为它之前从未在垃圾邮件或非垃圾邮件训练样本中看到过 “nips”，它认为在任一类型的电子邮件中看到它的概率为零。因此，当试图确定这些包含 “nips” 的消息之一是否是垃圾邮件时，它会计算后验概率，并得到&lt;/p&gt;
$$
\begin{array}{lcl}
p(y = 1 \mid x)&amp; = &amp;
\displaystyle
\frac{
\left( \prod_{i=1}^{n} p(x_i \mid y = 1) \right) p(y = 1)
}{
\left( \prod_{i=1}^{n} p(x_i \mid y = 1) \right) p(y = 1)+
\left( \prod_{i=1}^{n} p(x_i \mid y = 0) \right) p(y = 0)
} \\
&amp; = &amp; \displaystyle \frac{0}{0}
\end{array}
$$&lt;p&gt;这是因为$\prod_{i=1}^{n} p(x_i \mid y)$中的每一项都包含$p(x_{35000} \mid y) = 0$。因此，我们的算法获得 $0/0$，并且不知道如何进行预测。&lt;/p&gt;
&lt;p&gt;更广泛地，仅仅因为你之前没有在有限训练集中看到它，估计一些事件的概率为零在统计上是个坏主意。考虑估计取值在 ${1,\ldots,k}$ 的多项分布随机变量 $z$ 的均值问题。我们可以用$\phi_j = p(z = j)$参数化我们的多项式。给定一组 $m$ 个独立观测变量${z^{(1)}, \ldots, z^{(m)}}$，最大似然估计由下式给出&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_j&amp; = &amp;
\displaystyle
\frac{\sum_{i=1}^{m} \mathbf{1}\{z^{(i)} = j\}}{m}
\end{array}
$$&lt;p&gt;正如我们之前看到的，如果我们使用这些最大似然估计，那么一些 $\phi_j$ 可能最终为零，这就会产生问题。为了避免这种情况，我们可以使用&lt;strong&gt;拉普拉斯平滑&lt;/strong&gt;，它取代上面的估计&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_j&amp; = &amp;
\displaystyle
\frac{\sum_{i=1}^{m} \mathbf{1}\{z^{(i)} = j\} + 1}{m + k}
\end{array}
$$&lt;p&gt;这里，我们对分子加 1，对分母加 $k$。注意$\sum_{j=1}^{k} \phi_j = 1$仍然成立。对于所有 $j$，$\phi_j \neq 0$。在某些（可以说是相当强的）条件下，可以证明拉普拉斯平滑实际上给出了 $\phi_j$ 的最优估计。&lt;/p&gt;
&lt;p&gt;返回我们的朴素贝叶斯分类器，使用拉普拉斯平滑，我们因此得到以下参数估计：&lt;/p&gt;
$$
\begin{array}{lcl}
\phi_{35000 \mid y=1}
&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{x_{35000}^{(i)} \wedge y^{(i)} = 1\} + 1
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 1\} + 2
}
\\
\phi_{35000 \mid y=0}
&amp; = &amp;
\displaystyle
\frac{
\sum_{i=1}^{m} \mathbf{1}\{x_{35000}^{(i)} \wedge y^{(i)} = 0\} + 1
}{
\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\} + 2
}
\end{array}
$$</description></item><item><title>CS229 Lecture 5</title><link>https://lunatide.tech/p/cs229-lecture-5/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-5/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-5/pic1.jpg" alt="Featured image of post CS229 Lecture 5" /&gt;&lt;h2 id="生成学习算法"&gt;生成学习算法
&lt;/h2&gt;&lt;p&gt;目前为止说过的学习算法的模型都是$p(y \mid x;\theta)$，也就是给定$x$下的$y$的条件分布，以$\theta$为参数。例如，逻辑回归就是以$h_{\theta}(x)=g(\theta^Tx)$作为$p(y \mid x;\theta)$的模型，这里的$g$是一个sigmoid函数，接下来要讲一个不同类型的学习算法。&lt;/p&gt;
&lt;p&gt;设想有这样的一种分类问题，我们要学习基于一个动物的某个特征来辨别它是大象(y=1)还是小狗(y=0)。给定一个训练集，用逻辑回归或者基础版的感知器算法这样的一个算法能找到一条直线，作为区分大象和小狗的边界。然后我们只要看值落在哪个区域就可以分辨出是大象还是小狗。&lt;/p&gt;
&lt;p&gt;或者还有另外一种算法。首先，观察大象，然后我们针对大象的样子来进行建模。然后再观察小狗，针对小狗的样子另外建立一个模型。最后我们只需要把动物和这两个模型比对，越接近哪个就是哪个动物。&lt;/p&gt;
&lt;p&gt;例如逻辑回归之类的直接试图建立$p(y \mid x)$的算法，以及感知器算法等直接用投图的思路来判断对应$X$的值落到了{0，1}中哪个区域的算法，这些都叫判别式学习算法。和之前的这些判别式算法不同，下面我们要讲的新算法是对$p(y \mid x)$和$p(y)$来进行建模。这类算法叫做&lt;strong&gt;生成学习算法&lt;/strong&gt;。例如如果$y$是用来表示一个样例是小狗(0)或者大象(1)，那么$p(x \mid y=0)$就是对小狗特征的分布的建模，反之，$p(x \mid y=1)$就是对大象特征分布的建模。&lt;/p&gt;
&lt;p&gt;在对 $p(y)$（称为&lt;strong&gt;分类先验&lt;/strong&gt;）和 $p(x \mid y)$ 进行建模之后，我们的算法可以使用贝叶斯法则在给定 $x$ 的情况下输出后验分布：
&lt;/p&gt;
$$
p(y \mid x) = \frac{p(x \mid y)p(y)}{p(x)}.
$$&lt;p&gt;这里，分母
&lt;/p&gt;
$$
p(x) = p(x \mid y=1)p(y=1) + p(x \mid y=0)p(y=0)
$$&lt;p&gt;
给出，因此也可以用我们学习到的 $p(x \mid y)$ 和 $p(y)$ 表示。实际上，如果为了进行预测而计算 $p(y \mid x)$，那么我们实际上并不需要计算分母，因为&lt;/p&gt;
$$
\arg\max_y p(y \mid x)
= \arg\max_y \frac{p(x \mid y)p(y)}{p(x)}
= \arg\max_y p(x \mid y)p(y).
$$&lt;h3 id="高斯判别分析"&gt;高斯判别分析
&lt;/h3&gt;&lt;p&gt;我们要学习的第一个生成学习算法就是高斯判别分析，在这个模型里面，我们假设$p(x \mid y)$是一个多元正态分布。所以首先我们简单讲下多元正态分布的一些特点&lt;/p&gt;
&lt;h4 id="多元正态分布"&gt;多元正态分布
&lt;/h4&gt;&lt;p&gt;$n$ 维的多元正态分布，也称为多元高斯分布，由&lt;strong&gt;均值向量&lt;/strong&gt; $\mu \in \mathbb{R}^n$ 以及&lt;strong&gt;协方差矩阵&lt;/strong&gt;$\Sigma \in \mathbb{R}^{n \times n}$ 参数化，其中 $\Sigma \ge 0$ 是半正定对称矩阵。多元正态分布也写为 $\mathcal{N}(\mu, \Sigma)$，其密度由下式给出：&lt;/p&gt;
$$
p(x; \mu, \Sigma)
= \frac{1}{(2\pi)^{n/2} \lvert \Sigma \rvert^{1/2}}
\exp\!\left(
-\frac{1}{2}(x-\mu)^T \Sigma^{-1} (x-\mu)
\right).
$$&lt;p&gt;
在上面的等式中，“$|\Sigma|$”的意思是矩阵 $\Sigma$ 的行列式，对于一个在 $\mathcal{N}(\mu,\Sigma)$ 分布中的随机变量 $X$，其平均值就是$\mu$了
&lt;/p&gt;
$$
E[X] = \int_x x\, p(x;\mu,\Sigma)\, dx = \mu.
$$&lt;p&gt;
向量值随机变量 $Z$ 的&lt;strong&gt;协方差&lt;/strong&gt;定义为$\mathrm{Cov}(Z) = E[(Z - E[Z])(Z - E[Z])^T]$。这概括了实值随机变量方差的概念。协方差也可以定义为$\mathrm{Cov}(Z) = E[ZZ^T] - (E[Z])(E[Z])^T$。如果 $X \sim \mathcal{N}(\mu,\Sigma)$，那么&lt;/p&gt;
$$
\mathrm{Cov}(X) = \Sigma
$$&lt;h4 id="高斯判别分析模型"&gt;高斯判别分析模型
&lt;/h4&gt;&lt;p&gt;假如我们有一个分类问题，其中输入特征$x$是一系列的连续随机变量，那就可以使用高斯判别分析模型，其中对$p(x \mid y)$用多元正态分布来进行建模，这个模型为：
&lt;/p&gt;
$$
\begin{array}{c}
y \sim \mathrm{Bernoulli}(\phi) \\
x \mid y=0 \sim \mathcal{N}(\mu_0,\Sigma) \\
x \mid y=1 \sim \mathcal{N}(\mu_1,\Sigma)
\end{array}
$$&lt;p&gt;分布写出来的具体形式如下：&lt;/p&gt;
$$
\begin{array}{rcl}
p(y) &amp;=&amp; \phi^y(1-\phi)^{1-y} \\
p(x \mid y=0) &amp;=&amp; \dfrac{1}{(2\pi)^{n/2}\,|\Sigma|^{1/2}}
\exp\!\left(-\dfrac{1}{2}(x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right) \\
p(x \mid y=1) &amp;=&amp; \dfrac{1}{(2\pi)^{n/2}\,|\Sigma|^{1/2}}
\exp\!\left(-\dfrac{1}{2}(x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)
\end{array}
$$&lt;p&gt;
这里，我们的模型的参数是 $\phi, \Sigma, \mu_0, \mu_1$。（虽然存在两个不同的均值向量 $\mu_0$ 和 $\mu_1$，但是该模型通常仅使用同一个协方差矩阵 $\Sigma$。）数据的对数似然性由下式给出：&lt;/p&gt;
$$
\ell(\phi,\mu_0,\mu_1,\Sigma)
= \log \prod_{i=1}^m p(x^{(i)}, y^{(i)};\phi,\mu_0,\mu_1,\Sigma)
$$$$
= \log \prod_{i=1}^m
p(x^{(i)} \mid y^{(i)};\mu_0,\mu_1,\Sigma)\,
p(y^{(i)};\phi).
$$&lt;p&gt;通过参数最大化$l$，然后就能找到该参数组合对应的最大似然估计如下
&lt;/p&gt;
$$
\begin{array}{rcl}
\phi
&amp;=&amp; \dfrac{1}{m}\displaystyle\sum_{i=1}^m 1\{y^{(i)} = 1\} \\
\mu_0
&amp;=&amp; \dfrac{\displaystyle\sum_{i=1}^m 1\{y^{(i)} = 0\}\, x^{(i)}}
{\displaystyle\sum_{i=1}^m 1\{y^{(i)} = 0\}} \\
\mu_1
&amp;=&amp; \dfrac{\displaystyle\sum_{i=1}^m 1\{y^{(i)} = 1\}\, x^{(i)}}
{\displaystyle\sum_{i=1}^m 1\{y^{(i)} = 1\}} \\
\Sigma
&amp;=&amp; \dfrac{1}{m}\displaystyle\sum_{i=1}^m
\big(x^{(i)} - \mu_{y^{(i)}}\big)
\big(x^{(i)} - \mu_{y^{(i)}}\big)^T
\end{array}
$$&lt;p&gt;
推导过程如下：&lt;/p&gt;
&lt;p&gt;先观察 $P(x \mid y)$ 的形式，可以得到如下公式&lt;/p&gt;
$$
P(x\mid y)=\frac{1}{(2\pi)^{n/2}\,|\Sigma|^{1/2}}
\exp\!\left(-\frac{1}{2}(x-\mu_y)^{T}\Sigma^{-1}(x-\mu_y)\right)
$$&lt;p&gt;
接着计算 $\log P(x,y)$&lt;/p&gt;
$$
\begin{array}{rcl}
\log P(x,y)
&amp; = &amp;
\log P(x\mid y)P(y)\\
&amp; = &amp;
\log\Bigg(
\frac{1}{(2\pi)^{n/2}\lvert\Sigma\rvert^{1/2}}
\exp\!\left(
-\frac{1}{2}(x-\mu_y)^T\Sigma^{-1}(x-\mu_y)
\right)
\phi^{1(y=1)}
(1-\phi)^{1(y=0)}
\Bigg)\\
&amp; = &amp;
\,-\frac{n}{2}\log(2\pi)
\,-\frac{1}{2}\log\lvert\Sigma\rvert
\,-\frac{1}{2}(x-\mu_y)^T\Sigma^{-1}(x-\mu_y)+ 1(y=1)\log\phi+ 1(y=0)\log(1-\phi)
\end{array}
$$&lt;p&gt;
对数似然函数为：&lt;/p&gt;
$$
\begin{aligned}
\ell(\phi,\mu_0,\mu_1,\Sigma)
&amp;= \log\prod_{i=1}^{m} p(x^{(i)},y^{(i)};\phi,\mu_0,\mu_1,\Sigma) \\
&amp;= \sum_{i=1}^{m}
\log p(x^{(i)},y^{(i)};\phi,\mu_0,\mu_1,\Sigma) \\
&amp;= \sum_{i=1}^{m}\Bigg(
\log\frac{1}{(2\pi)^{n/2}\det(\Sigma)^{1/2}}
-\frac{1}{2}(x^{(i)}-\mu_{y^{(i)}})^T
\Sigma^{-1}(x^{(i)}-\mu_{y^{(i)}})+ 1(y^{(i)}=1)\log\phi+ 1(y^{(i)}=0)\log(1-\phi)
\Bigg)
\end{aligned}
$$&lt;p&gt;
关于 $\phi$ 求梯度
&lt;/p&gt;
$$
\begin{array}{rcl}
\displaystyle\frac{\partial \ell}{\partial \phi}
&amp;=&amp; \displaystyle
\sum_{i=1}^{m}
\left(
\frac{\mathbf{1}\{y^{(i)}=1\}}{\phi}
-\frac{\mathbf{1}\{y^{(i)}=0\}}{1-\phi}
\right)
= 0
&amp;\Longrightarrow&amp;
\displaystyle\sum_{i=1}^{m}\mathbf{1}\{y^{(i)}=1\}
= m\phi
&amp;\Longrightarrow&amp;
\displaystyle
\phi=\frac{1}{m}\sum_{i=1}^{m}\mathbf{1}\{y^{(i)}=1\}
\end{array}
$$&lt;p&gt;关于 $\mu_1,\mu_0$ 求梯度
&lt;/p&gt;
$$
\begin{array}{rcl}
\nabla_{\mu_1}\ell
&amp;=&amp; \displaystyle
\sum_{i=1}^{m}
\Sigma^{-1}(x^{(i)}-\mu_{y^{(i)}})\,
1_{y^{(i)}=1}
= 0
&amp;\Longrightarrow&amp;
\sum_{i=1}^{m}
(x^{(i)}-\mu_1)\,
1_{y^{(i)}=1}
= 0
&amp;\Longrightarrow&amp;
\mu_1=\frac{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\} \, x^{(i)}}{\sum_{i=1}^{m} \mathbf{1}\{y^{(i)} = 0\}}
\end{array}
$$&lt;p&gt;
关于 $\Sigma$ 的极大似然估计
&lt;/p&gt;
$$
\nabla_A \log|A| = (A^{-1})^T,
\nabla_A(x^T A y) = xy^T
$$$$
\begin{array}{rcl}
\nabla_{\Sigma^{-1}}\ell
&amp;=&amp; \nabla_{\Sigma^{-1}}
\left(
\frac{m}{2}\log|\Sigma^{-1}|
\right)
-\frac{1}{2}\nabla_{\Sigma^{-1}}
\sum_{i=1}^{m}
(x^{(i)}-\mu_{y^{(i)}})^T
\Sigma^{-1}
(x^{(i)}-\mu_{y^{(i)}})
= 0
&amp;\Longrightarrow&amp;
\displaystyle
\frac{m}{2}\Sigma
-\frac{1}{2}\sum_{i=1}^{m}
(x^{(i)}-\mu_{y^{(i)}})
(x^{(i)}-\mu_{y^{(i)}})^T
= 0
&amp;\Longrightarrow&amp;
\displaystyle
\Sigma
=\frac{1}{m}\sum_{i=1}^{m}
(x^{(i)}-\mu_{y^{(i)}})
(x^{(i)}-\mu_{y^{(i)}})^T
\end{array}
$$&lt;p&gt;因此结论成立。&lt;/p&gt;
&lt;h3 id="讨论高斯判别分析与logistic回归"&gt;讨论：高斯判别分析与logistic回归
&lt;/h3&gt;&lt;p&gt;高斯判别分析模型与逻辑回归有很有趣的相关性。如果我们把变量 $ p(y = 1 \mid x; \phi, \mu_0, \mu_1, \Sigma) $作为一个 \(x\) 的函数，就会发现可以用如下的形式来表达：&lt;/p&gt;
$$
p(y = 1 \mid x; \phi, \Sigma, \mu_0, \mu_1)=\frac{1}{1 + \exp(-\theta^T x)}
$$&lt;p&gt;其中的 \(\theta\) 是对 \(\phi, \Sigma, \mu_0, \mu_1\) 的某种函数。这就是逻辑回归（也是一种判别分析算法）用来对\( p(y = 1 \mid x) \)建模的形式。&lt;/p&gt;
&lt;p&gt;Proof：&lt;/p&gt;
&lt;p&gt;先计算 \( P(x) \)&lt;/p&gt;
$$
P(x)=P(y = 1) P(x \mid y = 1)+P(y = 0) P(x \mid y = 0)
$$$$
\left.
\begin{array}{l}
P(x)=
\phi
\dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac{1}{2}(x-\mu_1)^T \Sigma^{-1}(x-\mu_1)
\right)+
(1-\phi)
\dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac{1}{2}(x-\mu_0)^T \Sigma^{-1}(x-\mu_0)
\right)
\end{array}
\right.
$$&lt;p&gt;利用贝叶斯公式计算 \( P(y \mid x) \)，分别对 \( y = 1, y = 0 \) 计算：&lt;/p&gt;
$$
P(y \mid x)=
\frac{P(x \mid y) P(y)}{P(x)}
$$&lt;p&gt;因此，&lt;/p&gt;
$$
\left.
\begin{array}{lcl}
P(y=1 \mid x)
&amp; = &amp;
\dfrac{P(x \mid y=1)P(y=1)}
{\phi \dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac12 (x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)
+(1-\phi)\dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac12 (x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right)} \\[1em]
&amp; = &amp;
\dfrac{\dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac12 (x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)\phi}
{\phi \dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac12 (x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)
+(1-\phi)\dfrac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}
\exp\!\left(-\dfrac12 (x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right)} \\[1em]
&amp; = &amp;
\dfrac{1}
{1+\dfrac{1-\phi}{\phi}
\exp\!\left(
-\dfrac12 (x-\mu_0)^T\Sigma^{-1}(x-\mu_0)
+\dfrac12 (x-\mu_1)^T\Sigma^{-1}(x-\mu_1)
\right)}
\end{array}
\right.
$$&lt;p&gt;
计算指数部分
&lt;/p&gt;
$$
\left.
\begin{array}{lcl}-\dfrac12 (x-\mu_0)^T\Sigma^{-1}(x-\mu_0)+ \dfrac12 (x-\mu_1)^T\Sigma^{-1}(x-\mu_1)&amp; = &amp;
\dfrac{1}{2}
\Big(
x^T\Sigma^{-1}x- 2\mu_1^T\Sigma^{-1}x+ \mu_1^T\Sigma^{-1}\mu_1 - x^T\Sigma^{-1}x+ 2\mu_0^T\Sigma^{-1}x- \mu_0^T\Sigma^{-1}\mu_0
\Big) \\&amp; = &amp;
\dfrac{1}{2}
\Big(
2(\mu_0^T\Sigma^{-1}-\mu_1^T\Sigma^{-1})x+ \mu_1^T\Sigma^{-1}\mu_1- \mu_0^T\Sigma^{-1}\mu_0
\Big) \\&amp; = &amp;
(\mu_0^T\Sigma^{-1}-\mu_1^T\Sigma^{-1})x+ \dfrac{1}{2}
\big(
\mu_1^T\Sigma^{-1}\mu_1- \mu_0^T\Sigma^{-1}\mu_0
\big)
\end{array}
\right.
$$&lt;p&gt;
so
&lt;/p&gt;
$$
\left.
\begin{array}{lcl}
P(y=1 \mid x)
&amp; = &amp;
\dfrac{1}
{1 + \dfrac{1-\phi}{\phi}
\exp\!\left(
(\mu_0^T\Sigma^{-1}-\mu_1^T\Sigma^{-1})x+ \dfrac12(\mu_1^T\Sigma^{-1}\mu_1-\mu_0^T\Sigma^{-1}\mu_0)
\right)} \\
&amp; = &amp;
\dfrac{1}
{1 + \exp\!\left(
(\mu_0^T\Sigma^{-1}-\mu_1^T\Sigma^{-1})x+ \dfrac12(\mu_1^T\Sigma^{-1}\mu_1-\mu_0^T\Sigma^{-1}\mu_0)+ \ln\dfrac{1-\phi}{\phi}
\right)}
\end{array}
\right.
$$&lt;p&gt;
令
&lt;/p&gt;
$$
\left.
\theta=
(\mu_1^T\Sigma^{-1}-\mu_0^T\Sigma^{-1})^T= \Sigma^{-1}(\mu_1-\mu_0) \qquad
\theta_0=-\dfrac12(\mu_1^T\Sigma^{-1}\mu_1-\mu_0^T\Sigma^{-1}\mu_0)- \ln\dfrac{1-\phi}{\phi}
\right.
$$&lt;p&gt;
从而
&lt;/p&gt;
$$
\left.
p(y=1 \mid x;\phi,\Sigma,\mu_0,\mu_1)=
\dfrac{1}{1+\exp\!\big(-(\theta^T x+\theta_0)\big)}
\right.
$$&lt;p&gt;
那么这两个模型，我们应该如何选择呢？一般来说，高斯判别分析和logistic回归，对同一个训练集，可能给出的判别曲线是不一样的。哪一个更好一点呢？&lt;/p&gt;</description></item><item><title>CS229 Lecture 4</title><link>https://lunatide.tech/p/cs229-lecture-4/</link><pubDate>Thu, 01 Jan 2026 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-4/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-4/pic1.jpg" alt="Featured image of post CS229 Lecture 4" /&gt;&lt;p&gt;现在是2026年01月01号的00:00，该更新note了！新年快乐！&lt;/p&gt;
&lt;h3 id="另外一种最大化ltheta的算法"&gt;另外一种最大化$l(\theta)$的算法
&lt;/h3&gt;&lt;p&gt;回到logistic回归，其中$g(z)$是sigmoid函数，现在让我们讨论一种最大化$l(\theta)$的不同算法&lt;/p&gt;
&lt;p&gt;我们先想一下求一个方程零点的牛顿法。假设我们有一个从实数到实数$ f : \mathbb{R} \to \mathbb{R} $，然后要找到一个$\theta$，来满足 $f(\theta)=0$，其中$0 \in \mathbb{R}$。牛顿法就是对 $\theta$ 进行如下的更新：
&lt;/p&gt;
$$
\theta := \theta - \frac{f(\theta)}{f'(\theta)}\tag{1}
$$&lt;p&gt;
这个方法可以通过一个很自然的解释，我们可以把它理解成用一个线性函数来对函数 $f$ 进行逼近，这条直线是 $f$ 的切线，求解线性函数等于0的位置，并让下一个$\theta$ 的猜测为线性函数为0的地方&lt;/p&gt;
&lt;p&gt;下面是牛顿法的图解&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-4/p1.jpg"
width="887"
height="251"
srcset="https://lunatide.tech/p/cs229-lecture-4/p1_hu_6f45aff28d8f90d3.jpg 480w, https://lunatide.tech/p/cs229-lecture-4/p1_hu_14fecb85cb6da5d2.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="353"
data-flex-basis="848px"
&gt;&lt;/p&gt;
&lt;p&gt;在最左边的图中，我们可以看到函数 $f$ 就是沿着 $y = 0$ 的一条直线。这时候是想要找一个 $\theta$ 来让函数值等于0，这时候发现这个 $\theta$ 值大概在1.3左右。假设我们设定初始值$\theta=4.5$。牛顿法就是在$\theta=4.5$的地方画一条切线（中间的图，这样就给出了下一个 $\theta$ 猜测值的地方，也就是这个切线的零点，大概是2.8。最右面的图中是再次进行一次这样的迭代后的结果，这时候的 $\theta$ 大概为1.8。这样多次迭代过后，很快就能接近 $\theta=1.3$&lt;/p&gt;
&lt;p&gt;牛顿方法给出了一种求解$f(\theta)=0$的方法。如果我们想用它来最大化某些函数 $l$ 该怎么做？$l$ 的最大值对应于其一阶导数 $l&amp;rsquo;(\theta)$ 为零的点。因此，通过令 $f(\theta)=l&amp;rsquo;(\theta)$，我们可以用相同的算法来最大化 $l$，并且我们获得更新规则：
&lt;/p&gt;
$$
\theta := \theta-\frac{l'(\theta)}{l''(\theta)}\tag{2}
$$&lt;p&gt;
（最小化 $l$ 也是使用上述更新规则）&lt;/p&gt;
&lt;p&gt;最后，在我们的logistic回归背景中，$\theta$ 是一个有值的向量，所以我们要对牛顿法进行扩展来适应这个情况。牛顿法进行扩展到多维情况，也叫牛顿-拉普森法（Newton-Raphson method）吗，如下
&lt;/p&gt;
$$
\theta := \theta - H^{-1} \nabla_\theta \ell(\theta)\tag{3}
$$&lt;p&gt;
在这里，\( \nabla \ell(\theta) \) 和往常一样，是 \( \ell(\theta) \) 关于 \( \theta_i \) 的偏导数的向量。而 \(H\) 是一个 \( n \times n \) 矩阵（实际上是\( (n+1) \times (n+1) \)，假设我们包括截距项），称为 Hessian。矩阵的每一项由下式给出：&lt;/p&gt;
$$
H_{ij} = \frac{\partial^2 \ell(\theta)}{\partial \theta_i \, \partial \theta_j}\tag{4}
$$&lt;p&gt;
牛顿法通常都能比（批量）梯度下降法收敛得更快，而且达到最小值所需要的迭代次数也低很多。然而，牛顿法中的单次迭代往往要比梯度下降法的单步耗费更多的性能开销，因为要查找和转换一个 \( n \times n \) 的Hessian矩阵；不过只要这个n不是太大，牛顿法通常还是更快一些。只用牛顿法来logistic回归中求似然函数 $l(\theta)$ 的最大值的时候，得到这个结果的方法叫做&lt;strong&gt;Fisher积分&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="广义线性模型"&gt;广义线性模型
&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经看到了回归样例和分类样例。在回归样例中，我们有 \( y \mid x; \theta \sim \mathcal{N}(\mu, \sigma^2) \)， 在分类中， \( y \mid x; \theta \sim \text{Bernoulli}(\phi) \)， \( \mu \) 和 \( \phi \) 定义为 \( x \) 和 \(\theta\) 的函数。在本节中，我们将展示这两种方法都是更广泛的模型族的特例，称为&lt;strong&gt;广义线性模型（GLM）&lt;/strong&gt;。我们还将展示如何推导 GLM 族中的其他模型，并将其应用于其他分类和回归问题。&lt;/p&gt;
&lt;h3 id="指数族"&gt;指数族
&lt;/h3&gt;&lt;p&gt;为了完成GLM，我们将首先定义指数族分布。我们说一类分布属于指数族，如果它们可以表达为如下形式：
&lt;/p&gt;
$$
p(y; \eta) = b(y)\,\exp\!\big(\eta^{T} T(y) - a(\eta)\big)\tag{5}
$$&lt;p&gt;
在这里，$\eta$ 称为分布的&lt;strong&gt;自然参数&lt;/strong&gt;（也称为&lt;strong&gt;规范参数&lt;/strong&gt;）；$T(y)$是&lt;strong&gt;充分统计量&lt;/strong&gt;，我们目前用的这些分布中通常 $T(y)=y$；而$a(\eta)$是一个&lt;strong&gt;对数分割函数&lt;/strong&gt;。$e^{-a(\eta)}$这个量本质上扮演了归一化常数的角色，也就是确保$p(y;\eta)$的综合或者积分等于1&lt;/p&gt;
&lt;p&gt;定义分布族的$T,a,b$由$\eta$参数化；当我们改变$\eta$的时候，我们在这个族中会获得不同的分布&lt;/p&gt;
&lt;p&gt;现在我们看到的伯努利分布和高斯分布就都属于指数分布族。伯努利分布的均值是$ \phi $，也写作Bernoulli($ \phi $)，确定的分布是$y \in {0,1}$，因此有 $p(y=1;\phi) = \phi;p(y=0;\phi)=1-\phi$。这时候只要修改$ \phi $，我们获得不同均值的伯努利分布。我们现在表明，这类伯努利分布，即通过变化$ \phi $获得的分布，是指数族；即，可以选择$T,a,b$，使得等式(5)恰好成为伯努利分布&lt;/p&gt;
&lt;p&gt;我们现在将伯努利分布改写：
&lt;/p&gt;
$$
\begin{aligned}
p(y; \eta)
&amp;= \phi^{y}(1-\phi)^{1-y} \\
&amp;= \exp\!\big(y \log \phi + (1-y)\log(1-\phi)\big) \\
&amp;= \exp\!\left(\left(\log\frac{\phi}{1-\phi}\right)y + \log(1-\phi)\right)
\end{aligned}
$$&lt;p&gt;
因此，自然参数由$ \phi=log(\phi/(1-\phi)) $给出，有趣的是，如果我们翻转这个定义，用$\eta$来解 $\phi$ 就会得到 $\phi=1/(1+e^{-\eta})$。这正好就是之前我们刚刚见过的sigmoid函数！在我们把logistic回归作为一种广义线性模型（GLM）时还会遇到这个情况。
&lt;/p&gt;
$$
\begin{aligned}
T(y) &amp;= y \\
a(\eta) &amp;= -\log(1-\phi) \\
&amp;= \log(1 + e^{\eta}) \\
b(y) &amp;= 1
\end{aligned}
$$&lt;p&gt;
上面的这组式子就表明了伯努利分布可以写成等式(6)的形式，使用一组合适的$T,a,b$&lt;/p&gt;
&lt;p&gt;接下来继续看高斯分布。回顾一下，当推导出线性回归的时候，\( \sigma^2 \) 的值对 \(\theta\) 和 \( h(x) \) 的最终选择没有影响。因此，我们可以选择任意值的 \( \sigma^2 \) 而不改变任何东西。为了简化下面的推导，让我们令 \( \sigma^2 = 1 \)，然后我们有：
&lt;/p&gt;
$$
\begin{aligned}
p(y; \mu)
&amp;= \frac{1}{\sqrt{2\pi}}
\exp\!\left(-\frac{1}{2}(y-\mu)^2\right) \\
&amp;= \frac{1}{\sqrt{2\pi}}
\exp\!\left(-\frac{1}{2}y^2\right)
\cdot
\exp\!\left(\mu y - \frac{1}{2}\mu^2\right)
\end{aligned}
$$&lt;p&gt;因此，我们看到高斯分布是指数族，并且有：&lt;/p&gt;
$$
\begin{aligned}
\eta &amp;= \mu \\
T(y) &amp;= y \\
a(\eta) &amp;= mu^2/2 \\
&amp;= \eta^2/2 \\
b(y) &amp;= (1/\sqrt{2\pi}) \exp\!\left(-y^2/2\right)
\end{aligned}
$$&lt;p&gt;
指数分布族里面还有很多其他的分布，例如多项式分布，这个待会就能看到；泊松分布，用来对计数类数据进行建模；伽马和指数分布，用于对连续的、非负的随机变量进行建 模，例如时间间隔；$\beta$ 和狄利克雷分布，用于概率的分布；还有很多，在下一节我们会描述建模型的一般方法，其中$y$（给定$ x $和$\theta$）来自任何这些分布&lt;/p&gt;
&lt;h3 id="构造glm"&gt;构造GLM
&lt;/h3&gt;&lt;p&gt;设想你要构建一个模型，来估计在给定的某个小时内来到你的商店的顾客人数（或者是你的网站的页面访问次数），基于某些确定的特征$ x $，例如商店的促销，最近的广告，天气，今天周几等等。我们已经知道泊松分布通常能适合用来对方可数目进行建模。知道了这个之后，怎么来建立一个模型来解决咱们这个具体问题呢？非常幸运的是，泊松分布是属于指数分布族的一个分部，所以我们可以使用一个广义线性模型（GLM）&lt;/p&gt;
&lt;p&gt;更一般地，考虑一个分类或者回归问题，我们希望将某个随机变量$y$的值预测为$ x $的函数。为了得到这个问题的GLM，我们将对给定$ x $和关于我们模型的$y$的条件分布做出以下三个假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$y \mid x, \theta \sim \text{Exponential Family}(\eta)$，其中在给定 \( x \) 和 \(\theta\) 的条件下，\(y\) 的分布属于指数分布族，参数为 \(\eta\)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给定$ x $，目的是要预测对应这个给定$ x $的T(y)的期望值。在我们的大多数例子中，我们有$T(y)=y$，所以着意味着我们希望我们的预测 $ h(x) $​满足&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$h(x) = E[y \mid x]$。（注意，这个假设通过对 $h_\theta(x)$ 的选择而满足，在逻辑回归和线性回归中都是如此。例如在逻辑回归中，&lt;/p&gt;
$$
h_\theta(x) = P(y = 1 \mid x; \theta)
= 0 \cdot P(y = 0 \mid x; \theta) + 1 \cdot P(y = 1 \mid x; \theta)
= E[y \mid x; \theta]
$$&lt;p&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自然参数 $\eta$ 和输入值 $ x $ 是线性相关的，$\eta = \theta^T x$，或者如果 $\eta$ 是有值的向量，则有 $\eta_i = \theta_i^T x$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些假设中的第三个看上去是最不和合理的假设，在我们构建GLM的方法中可能更好将其看作“设计选择”，而不是作为假设本身。这三个假设/设计选择将使我们能够得到一种非常优雅的学习算法，即GLM，它具有很多理想的属性，如易于学习。此外，得到的模型通常非常有效地用于对$y$上的不同类型的分布进行建模；例如，我们将很快展示logistic回归和普通最小二乘都可以作为GLM导出&lt;/p&gt;
&lt;h3 id="普通最小二乘"&gt;普通最小二乘
&lt;/h3&gt;&lt;p&gt;为了表明普通最小二乘是GLM模型族的特例，考虑目标变量$y$(也称为GLM术语中的&lt;strong&gt;响应变量&lt;/strong&gt;)是连续的情形，并且我们将给定的$ x $的$y$的条件分布建模为高斯分布&lt;/p&gt;
$$\mathcal{N}(\mu,\ \sigma^2)$$&lt;p&gt;，其中$ \mu $可以是依赖$ x $的一个函数。这样，我们就让上面的指数分布族的($\eta$)分布成为了一个高斯分布。在前面的内容中我们提到过，在把高斯分布写成指数分布族的分布的时候，有$ \mu = \eta $。所以就能得到下面的等式
&lt;/p&gt;
$$
\begin{aligned}
h_\theta(x) &amp;= E[y \mid x; \theta] \\
&amp;= \mu \\
&amp;= \eta \\
&amp;= \theta^T x
\end{aligned}
$$&lt;p&gt;
第一行的等式是基于假设 2；第二个等式是基于定理：当 $ y \mid x; \theta \sim \mathcal{N}(\mu, \sigma^2) $，则 $y$ 的期望就是 $ \mu $；第三个等式是基于假设 1，以及之前我们此前将高斯分布写成指数族分布的时候推导出来的性质 $ \mu = \eta $；最后一个等式就是基于假设 3。&lt;/p&gt;
&lt;h3 id="logistic回归"&gt;Logistic回归
&lt;/h3&gt;&lt;p&gt;我们现在考虑 Logistic 回归。这里我们对二元分类问题感兴趣，所以 $y \in {0, 1}$。鉴于 $y$ 是二值的，因此选择伯努利分布族来模拟给定 $ x $，$y$ 的条件分布似乎是自然的。在我们将伯努利分布表示为指数族分布时，我们得$\phi = \dfrac{1}{1 + e^{-\eta}}$。此外，请注意，如果$ y \mid x; \theta \sim \text{Bernoulli}(\phi) $，因此$E[y \mid x; \theta] = \phi$。因此，遵循与普通最小二乘法相似的推导，我们得到：&lt;/p&gt;
$$
\begin{aligned}
h_\theta(x) &amp;= E[y \mid x; \theta] \\
&amp;= \phi \\
&amp;= \dfrac{1}{1 + e^{-\eta}} \\
&amp;= \dfrac{1}{1 + e^{-\theta^T x}}
\end{aligned}
$$&lt;p&gt;因此，这给出了形如$h_\theta = \dfrac{1}{1 + e^{-\theta^T x}}$的假设函数。如果你以前想知道我们如何提出 logistic 函数$\dfrac{1}{1 + e^{-z}}$的形式，这给出了一个答案：一旦我们假设 $y$ 关于 $ x $ 的分布是伯努利分布，它就是 GLM 和指数族分布产生的结果。为了介绍更多的术语，给定分布的均值作为自然参数的函数$g , (g(\eta) = E[T(y); \eta])$被称为&lt;strong&gt;正则响应函数&lt;/strong&gt;。它的逆$g^{-1}$
称为&lt;strong&gt;正则关联函数&lt;/strong&gt;。因此，高斯族的正则响应函数是单位函数；伯努利的正则响应函数是 logistic 函数。&lt;/p&gt;
&lt;h3 id="softmax回归"&gt;Softmax回归
&lt;/h3&gt;&lt;p&gt;让我们看一下GLM的另一个例子。考虑一个分类问题，其中响应变量$y$可以取$k$个值中的任意一个，因此$y\in{1,2,&amp;hellip;,k}$。例如，我们可能希望将电子邮件分类为垃圾邮件，个人邮件和工作相关邮件等三类，而不是将电子邮件分类为垃圾邮件或非垃圾邮件这两类。响应变量仍然是离散的，但现在可以采用两个以上的值。因此，我们将根据多项分布对其进行建模&lt;/p&gt;
&lt;p&gt;让我们推导下GLM来建模这种多类别分类问题。为此，我们将首先将多项分布表示为指数族分布&lt;/p&gt;
&lt;p&gt;为了在 $k$ 个可能的结果上参数化多项分布，我们可以使用 $k$ 个参数$\phi_1, \ldots, \phi_k$指定每个结果的概率。然而，这些参数将是冗余的，或者更正式地，它们将不是独立的（因为知道 $\phi_i$ 的任何 $k-1$ 个值可以唯一地确定最后一个，因为它们必须满足$\sum_{i=1}^k \phi_i = 1$）。因此，我们将仅使用 $k-1$ 个参数，$\phi_1, \ldots, \phi_{k-1}$来参数化多项分布，其中
$\phi_i = p(y = i; \varphi)$，并且$p(y = k; \varphi) = 1 - \sum_{i=1}^{k-1} p(y = i; \varphi)$。为了方便起见，我们令$\phi_k = 1 - \sum_{i=1}^{k-1} \phi_i$，但我们应该记住，这不是一个参数，而是由$\phi_1, \ldots, \phi_{k-1}$完全确定。&lt;/p&gt;
&lt;p&gt;为了将多项分布表示为指数族分布，我们将$T(y) \in \mathbb{R}^{k-1}$定义如下：&lt;/p&gt;
$$
T(1)=
\begin{bmatrix}
1\\0\\0\\ \vdots\\0
\end{bmatrix},
\quad
T(2)=
\begin{bmatrix}
0\\1\\0\\ \vdots\\0
\end{bmatrix},
\quad
T(3)=
\begin{bmatrix}
0\\0\\1\\ \vdots\\0
\end{bmatrix},
\ \ldots,\
T(k-1)=
\begin{bmatrix}
0\\0\\0\\ \vdots\\1
\end{bmatrix},
\quad
T(k)=
\begin{bmatrix}
0\\0\\0\\ \vdots\\0
\end{bmatrix}.
$$&lt;p&gt;与我们之前的例子不同，这里我们没有$T(y) = y$；此外，$T(y)$ 现在是 $k-1$ 维向量，而不是实数。我们将用$(T(y))_i$来表示向量 $T(y)$ 的第 $i$ 个元素。&lt;/p&gt;
&lt;p&gt;我们介绍一个非常有用的符号。如果参数为真，则示性函数$1{\cdot}$的值为 $1$，否则为 $0$，即
&lt;/p&gt;
$$
1\{\text{True}\} = 1,\qquad
1\{\text{False}\} = 0.
$$&lt;p&gt;例如，$1{2 = 3} = 0$并且$1{3 = 5 - 2} = 1$。因此，我们也可以将 $T(y)$ 和 $y$ 之间的关系写为$(T(y))_i = 1{y = i}$此外，我们有$E[(T(y))_i] = P(y = i) = \phi_i$&lt;/p&gt;
&lt;p&gt;我们现在准备证明多项式是指数族的成员。我们有：&lt;/p&gt;
$$
\begin{array}{rcl}
p(y;\phi)
&amp;=&amp; \phi_1^{1\{y=1\}} \, \phi_2^{1\{y=2\}} \cdots \phi_k^{1\{y=k\}} \\[0.6em]
&amp;=&amp; \phi_1^{1\{y=1\}} \, \phi_2^{1\{y=2\}} \cdots \phi_k^{\,1-\sum_{i=1}^{k-1} 1\{y=i\}} \\[0.6em]
&amp;=&amp; \phi_1^{(T(y))_1} \, \phi_2^{(T(y))_2} \cdots \phi_k^{\,1-\sum_{i=1}^{k-1} (T(y))_i} \\[0.6em]
&amp;=&amp; \exp\big((T(y))_1 \log(\phi_1) + (T(y))_2 \log(\phi_2) + \cdots + \big(1-\sum_{i=1}^{k-1} (T(y))_i\big)\log(\phi_k)\big) \\[0.6em]
&amp;=&amp; \exp\big((T(y))_1 \log(\phi_1/\phi_k) + (T(y))_2 \log(\phi_2/\phi_k) + \cdots + (T(y))_{k-1} \log(\phi_{k-1}/\phi_k) + \log(\phi_k)\big) \\[0.6em]
&amp;=&amp; b(y)\exp\big(\eta^T T(y) - a(\eta)\big)
\end{array}
$$&lt;p&gt;
其中&lt;/p&gt;
$$
\begin{aligned}
\eta &amp;=
\begin{bmatrix}
\log(\phi_1/\phi_k) \\
\log(\phi_2/\phi_k) \\
\vdots \\
\log(\phi_{k-1}/\phi_k)
\end{bmatrix}, \\
a(\eta) &amp;= -\log(\phi_k), \\
b(y) &amp;= 1.
\end{aligned}
$$&lt;p&gt;
关联函数（对于 $i = 1,\ldots,k$）由下式给出：&lt;/p&gt;
$$
\eta_i = \log \frac{\phi_i}{\phi_k}.
$$&lt;p&gt;为方便起见，我们还定义$\eta_k = \log(\phi_k/\phi_k) = 0$。反转关联函数并导出响应函数，我们得到：&lt;/p&gt;
$$
\begin{aligned}
e^{\eta_i} &amp;= \frac{\phi_i}{\phi_k}, \\
\phi_k e^{\eta_i} &amp;= \phi_i, \\
\phi_k \sum_{i=1}^k e^{\eta_i} &amp;= \sum_{i=1}^k \phi_i = 1.
\end{aligned}
$$&lt;p&gt;这意味着 $\phi_k = 1 / \sum_{i=1}^k e^{\eta_i}$，可以将其代入上式以给出响应函数&lt;/p&gt;
$$
\phi_i = \frac{e^{\eta_i}}{\sum_{j=1}^k e^{\eta_j}}.
$$&lt;p&gt;从 $\eta$ 到 $\phi$ 的映射函数称为 &lt;strong&gt;softmax 函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了完成我们的模型，我们使用前面给出的假设 3，即 $\eta_i$ 与 $ x $ 线性相关。因此，有$\eta_i = \theta_i^T x$（对于 $i = 1,\ldots,k-1$），其中 $\theta_1,\ldots,\theta_{k-1} \in \mathbb{R}^{n+1}$ 是我们模型的参数。为了符号方便，我们还可以定义 $\theta_k = 0$，
所以 $\eta_k = \theta_k^T x = 0$，如之前所述。因此，我们的模型假设给定 $ x $，$y$ 的条件分布由下式给出：
&lt;/p&gt;
$$
\begin{array}{rcl}
p(y=i \mid x;\theta)
&amp;=&amp; \phi_i \\[6pt]
&amp;=&amp; \dfrac{e^{\eta_i}}{\sum_{j=1}^k e^{\eta_j}} \\[10pt]
&amp;=&amp; \dfrac{e^{\theta_i^T x}}{\sum_{j=1}^k e^{\theta_j^T x}}.
\end{array}
\tag{8}
$$&lt;p&gt;该模型适用于分类问题，其中 $y \in {1,\ldots,k}$，称为 &lt;strong&gt;softmax 回归&lt;/strong&gt;。它是 logistic 回归的推广。&lt;/p&gt;
&lt;p&gt;我们的假设将输出&lt;/p&gt;
$$
\begin{array}{rcl}
h_\theta(x) &amp;=&amp; \mathbb{E}[T(y)\mid x;\theta] \\[0.8em]
&amp;=&amp; \mathbb{E}\!\left[\begin{array}{c}
1\{y=1\} \\
1\{y=2\} \\
\vdots \\
1\{y=k-1\}
\end{array}\;\middle|\; x;\theta\right] \\[1.0em]
&amp;=&amp; \begin{bmatrix}
\phi_1 \\
\phi_2 \\
\vdots \\
\phi_{k-1}
\end{bmatrix} \\[1.0em]
&amp;=&amp; \begin{bmatrix}
\dfrac{e^{\theta_1^T x}}{\sum_{j=1}^k e^{\theta_j^T x}} \\
\dfrac{e^{\theta_2^T x}}{\sum_{j=1}^k e^{\theta_j^T x}} \\
\vdots \\
\dfrac{e^{\theta_{k-1}^T x}}{\sum_{j=1}^k e^{\theta_j^T x}}
\end{bmatrix}
\end{array}
$$&lt;p&gt;
换句话说，对于 $i = 1,\ldots,k$ 的每个值，我们的假设将输出 $p(y=i \mid x;\theta)$ 的概率估计值。（尽管如上定义的 $ h(x) $ 仅为 $k-1$ 维，但由 $1 - \sum_{i=1}^{k-1} \phi_i$显然可以得到 $p(y=k \mid x;\theta)$。）&lt;/p&gt;
&lt;p&gt;最后，让我们讨论参数拟合。类似于我们对普通最小二乘和 logistic 回归的原始推导，如果我们有一个训练集
${(x^{(i)},y^{(i)}); i=1,\ldots,m}$并且想要学习这个模型的参数 $ \theta_i $，我们首先写下对数似然：
&lt;/p&gt;
$$
\begin{array}{rcl}
\ell(\theta)
&amp;=&amp; \displaystyle \sum_{i=1}^m \log p\!\left(y^{(i)} \mid x^{(i)};\theta\right) \\[0.8em]
&amp;=&amp; \displaystyle \sum_{i=1}^m \log \prod_{l=1}^k
\left(
\frac{e^{\theta_l^T x^{(i)}}}
{\sum_{j=1}^k e^{\theta_j^T x^{(i)}}}
\right)^{1\{y^{(i)}=l\}}
\end{array}
$$&lt;p&gt;
为了获得上面的第二行，我们使用等式 (8) 中给出的$p(y \mid x;\theta)$ 的定义。我们现在可以通过使用诸如梯度上升或牛顿法之类的方法，关于 $\theta$ 来最大化 $ \ell(\theta) $，从而获得参数的最大似然估计。&lt;/p&gt;</description></item><item><title>CS229 Lecture 3</title><link>https://lunatide.tech/p/cs229-lecture-3/</link><pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-3/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-3/pic1.jpg" alt="Featured image of post CS229 Lecture 3" /&gt;&lt;h2 id="最小二乘法的概率解释"&gt;最小二乘法的概率解释
&lt;/h2&gt;&lt;p&gt;在面对回归问题的时候，我们会思考，为什么选择线性回归，为什么选择最小二乘法成本函数 &lt;strong&gt;J&lt;/strong&gt; ？在本节里会给出一系列的概率基本假设，基于这些假设，可以推出最小二乘法是一种非常自然的算法&lt;/p&gt;
&lt;p&gt;首先假设目标变量和输入值存在下面这种等量关系
&lt;/p&gt;
$$
y^{(i)}=\theta^Tx^{(i)}+\epsilon^{(i)}
$$&lt;p&gt;
上式中的 $\epsilon^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果或者随机的噪音信息。进一步假设$\epsilon^{(i)}$是独立同分布的（IID），服从高斯分布，其平均值为0，方差为$\sigma^2$，这样就可以把这个假设写成&amp;quot;$\epsilon^{(i)} \sim N(0,\sigma^2)$&amp;quot;，然后$\epsilon^{(i)}$的密度函数就是：
&lt;/p&gt;
$$
p(\epsilon^{(i)}) = \frac{1}{\sqrt{2\pi}\sigma} \exp\left( -\frac{(\epsilon^{(i)})^2}{2\sigma^2} \right)
$$&lt;p&gt;这意味着存在下面的等量关系：&lt;/p&gt;
$$
p(y^{(i)} \mid x^{(i)}; \theta) = \frac{1}{\sqrt{2\pi}\sigma} \exp\left( -\frac{(y^{(i)} - \theta^T x^{(i)})^2}{2\sigma^2} \right)
$$&lt;p&gt;
这里的记号 &amp;ldquo;$p(y^{(i)} \mid x^{(i)}; \theta)$&amp;ldquo;表示的是这是一个对于给定$x^{(i)}$的$y^{(i)}$的分布，用$\theta$进行了参数化，这里不能用&amp;rdquo;$p(y^{(i)} \mid x^{(i)}, \theta)$&amp;ldquo;来当作条件，因为$\theta$并不是一个随机变量，也可以将$y^{(i)}$的分布写成$y^{(i)} \mid x^{(i)};\theta \sim N(\theta^Tx^{(i)},\sigma^2)$&lt;/p&gt;
&lt;p&gt;给定一个 $X$ 为设计矩阵，包含了全部$x^{(i)}$，然后再给定$\theta$，那么$y^{(i)}$的分布是什么？数据的概率由$p(\vec{y} \mid X;\theta)$的形式给出。在$\theta$取某个固定值的情况下，这个等式通常可以看作一个$\vec{y}$的函数。当我们把它当作 $\theta$ 的函数时，就称它为似然函数
&lt;/p&gt;
$$
L(\theta)=L(\theta;X,\vec{y})= p(\vec{y} \mid X;\theta)
$$&lt;p&gt;
结合之前对 $\epsilon^{(i)}$ 的独立性假设(这里对$y^{(i)}$ 以及给定的$x^{(i)}$也都做同样假设)，就可以把上面这个等式改写成下面的形式
&lt;/p&gt;
$$
\begin{aligned}
L(\theta) &amp;= \prod_{i=1}^{m} p(y^{(i)} \mid x^{(i)}; \theta) \\
&amp;= \prod_{i=1}^{m} \left[ \frac{1}{\sqrt{2\pi}\sigma} \exp\left( -\frac{(y^{(i)} - \theta^T x^{(i)})^2}{2\sigma^2} \right) \right]
\end{aligned}
$$&lt;p&gt;
现在，给定了 $y^{(i)}$ 和 $x^{(i)}$ 之间关系的概率模型了，用什么方法来选择咱们对参数 $\theta$ 的最佳猜测呢，最大似然法告诉我们要选择能让数据的似然函数尽可能大的 $\theta$ 。也就是说，咱们要找的 $\theta$ 能够让函数 $L(\theta)$ 取到最大值&lt;/p&gt;
&lt;p&gt;为了运算方便，实际中我们选择最大化对数似然函数$l(\theta)$:
&lt;/p&gt;
$$
\begin{aligned}
\ell(\theta) &amp;= \log L(\theta) \\
&amp;= \log \prod_{i=1}^{m} \left[ \frac{1}{\sqrt{2\pi}\sigma} \exp\left( -\frac{(y^{(i)} - \theta^T x^{(i)})^2}{2\sigma^2} \right) \right] \\
&amp;= \sum_{i=1}^{m} \log \left[ \frac{1}{\sqrt{2\pi}\sigma} \exp\left( -\frac{(y^{(i)} - \theta^T x^{(i)})^2}{2\sigma^2} \right) \right] \\
&amp;= m \log \frac{1}{\sqrt{2\pi}\sigma}
\;-\; \frac{1}{2\sigma^2} \sum_{i=1}^{m} (y^{(i)} - \theta^T x^{(i)})^2
\end{aligned}
$$&lt;p&gt;
因此，对$l(\theta)$的最大值也就意味着下面这个子式取到最小值
&lt;/p&gt;
$$
\frac{1}{2} \sum_{i=1}^{m} (y^{(i)} - \theta^T x^{(i)})^2
$$&lt;p&gt;
上式即为$J(\theta)$，我们最初的最小二乘成本函数&lt;/p&gt;
&lt;p&gt;总结：在对数据进行概率假设的基础上，最小二乘回归得到的 $\theta$ 和最大似然法估计的 $\theta$ 是一致的。所以这是一系列的假设，其前提是认为最小二乘回归能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计&lt;/p&gt;
&lt;p&gt;还要注意，在刚才的讨论中，我们最终对 $\theta$ 的选择并不依赖 $\sigma^2$ ，而且也确实在不知道 $\sigma^2$ 的情况下就找到了结果。&lt;/p&gt;
&lt;h2 id="局部加权线性回归"&gt;局部加权线性回归
&lt;/h2&gt;&lt;p&gt;假如问题从 $x \in R$来预测 y。下面第一幅图显示了使用 $y=\theta_0+\theta_1x$来对一个数据集来进行拟合。我们明显能看出来这个数据的趋势不是一条严格的直线，所以用直线进行的拟合就不是好的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-3/p1.jpg"
width="1494"
height="430"
srcset="https://lunatide.tech/p/cs229-lecture-3/p1_hu_451db920bd6b617.jpg 480w, https://lunatide.tech/p/cs229-lecture-3/p1_hu_4b4f8c0d802f27a8.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="347"
data-flex-basis="833px"
&gt;&lt;/p&gt;
&lt;p&gt;那要是我们添加一个二次项，用 $y=\theta_0 + \theta_1x + \theta_2x^2$来拟合（上面中间的图），明显如果我们对特征补充得越多，效果就越好。不过增加太多的特征也会造成危险，看第三张图就是拟合5项多项式$y=\sum_{j=0}^{5}\theta_jx^j$的结果，可以看到，虽然拟合曲线完美地通过了所有当前数据集中的数据，但我们明显不能认为这个曲线是一个合适的预测工具，比如针对不同的居住面积 $x$ 来预测房屋价格 $y$ ，左边的图是一个&lt;strong&gt;欠拟合&lt;/strong&gt;的例子，明显看到漏掉了数据集中的结构信息，而最右边的图是&lt;strong&gt;过拟合&lt;/strong&gt;的例子&lt;/p&gt;
&lt;p&gt;因此，如上面例子所示，特征的选择对于确保学习算法的良好性能很重要，在本节，我们会简单地谈谈局部加权线性回归算法，这里假设有足够的训练数据，使得特征选择不那么重要&lt;/p&gt;
&lt;p&gt;在原始版本的线性回归算法中，要对一个查询点 $x$ 进行预测，比如要衡量 $h(x)$，要经过下面的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用参数 $\theta$ 进行拟合，让数据集中的值与拟合算出的值差值平方 $(y^{(i)} - \theta^Tx^{(i)})^2$最小（最小二乘法的思想）&lt;/li&gt;
&lt;li&gt;输出 $\theta^Tx$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相应地，在 LWR 局部加权线性回归的方法中，步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用参数 $\theta$ 进行拟合，让加权距离$w^{(i)}(y^{(i)}-\theta^Tx^{(i)})^2$最小&lt;/li&gt;
&lt;li&gt;输出$\theta^Tx$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面式子中的 $w^{(i)}$是非负的权值，直观地，如果$w^{(i)}$对于特定的 $i$ 很大，那么在选择 $\theta$ 时，我们将努力使 $(y^{(i)}-\theta^Tx^{(i)})$变小。如果$w^{(i)}$很小，则拟合中几乎忽略了 $(y^{(i)}-\theta^Tx^{(i)})^2$ 误差项&lt;/p&gt;
&lt;p&gt;对于权值的选择可以使用下面这个比较标准的公式：
&lt;/p&gt;
$$
w^{(i)}=\exp(- \frac{(x^{(i)}-x)^2}{2\tau^2} )
$$&lt;p&gt;
参数$\tau$控制训练样本的权重随着其$x^{(i)}$距查询点$x$的距离而下降的速度，$\tau$称为&lt;strong&gt;带宽参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部加权线性回归是我们看到的&lt;strong&gt;非参数&lt;/strong&gt;算法的第一个例子。我们之前看到的(未加权)线性回归算法被称为&lt;strong&gt;参数&lt;/strong&gt;算法，因为其具有固定的，有限数量的参数($\theta$)，这些参数由数据拟合。一旦我们拟合了$\theta_i$并将它们存储起来，我们就不再需要保留训练数据来做出对未来的预测，相反，如果用局部加权线性回归算法，我们就必须一直保留着整个训练集，这里的&amp;quot;非参数&amp;quot;粗略的指为了呈现出假设h遂着数据集的规模大增长而线性增长，我们需要用一定顺序保存一些数据的规模&lt;/p&gt;
&lt;h2 id="分类与逻辑回归"&gt;分类与逻辑回归
&lt;/h2&gt;&lt;p&gt;分类问题其实和回归问题很像，只不过我们现在要来预测的$y$的值只局限于少数的若干个离散值。首先关注的是二值化分类问题，也就是说咋们要判断的 $y$ 只有两个取值，0或者1（这里说到的大多数内容也将推广到多类情况）。例如，如果我们正在尝试为电子邮件构建垃圾邮件分类器，则 $x^{(i)}$ 可能是电子邮件的某些特征，如果是垃圾邮件，则$y$为1，否则为0。0也称为&lt;strong&gt;负类&lt;/strong&gt;，1表示&lt;strong&gt;正类&lt;/strong&gt;，它们有时也用符号&amp;rdquo;-&amp;ldquo;和&amp;rdquo;+&amp;ldquo;表示，给定$x^{(i)}$，相应的$y^{(i)}$也称为训练样本的&lt;strong&gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="logistic回归"&gt;Logistic回归
&lt;/h3&gt;&lt;p&gt;我们可以忽略$y$是离散值的事实来处理分类问题，并使用我们的旧线性回归算法来尝试预测给定的$x$的$y$。但是，很容易构造此方法的效果非常差的例子。直觉上，当我们知道$y \in {0,1}$，所以$h_0(x)$的值如果大于1或者小于0就没有意义了，就是说$y$的值必然应当是0和1这两个值中的一个&lt;/p&gt;
&lt;p&gt;所以咱们就改变一下假设函数$h_0(x)$的形式，来解决这个问题。比如咱们可以选择下面这个函数：
&lt;/p&gt;
$$
h_0(x)=g(\theta^Tx)= \frac{1}{1+e^{-\theta^Tx}}
$$&lt;p&gt;
其中有:
&lt;/p&gt;
$$
g(z) = \frac{1}{1+e^{-z}}
$$&lt;p&gt;
这个函数就是我们所熟悉的sigmoid函数，也叫做logistic函数，下面是它的图像&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-3/p2.jpg"
width="976"
height="694"
srcset="https://lunatide.tech/p/cs229-lecture-3/p2_hu_bc222519dbcf63cf.jpg 480w, https://lunatide.tech/p/cs229-lecture-3/p2_hu_388959615ff42ec7.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
&gt;&lt;/p&gt;
&lt;p&gt;注意到，当 $z \to \infty$ 时 $g(z)$ 趋近于 1，而当 $z \to -\infty$ 时 $g(z)$ 趋近于 0。 此外，$g(z)$ 和 $h(x)$ 的值总是在 0 和 1 之间波动。 我们保持 $x_0 = 1$ 的约定，所以$\theta^T x = \theta_0 + \sum_{j=1}^{n} \theta_j x_j$&lt;/p&gt;
&lt;p&gt;现在咱们就把 g 作为选定的函数了。当然其他的从0到1之间光滑递增的函数也可以使用，不过后面我们会了解到选择g的一些原因，对这个逻辑函数的选择是很自然的。在继续深入之前，在继续深入之前，下面通过导数讲解下这个函数的一些性质
&lt;/p&gt;
$$
\begin{aligned}
g'(z) &amp;= \frac{d}{dz} \frac{1}{1 + e^{-z}} \\
&amp;= \frac{1}{(1 + e^{-z})^{2}} \, (e^{-z}) \\
&amp;= \frac{1}{(1 + e^{-z})} \left( 1 - \frac{1}{1 + e^{-z}} \right) \\
&amp;= g(z)(1 - g(z)).
\end{aligned}
$$&lt;p&gt;
给定了逻辑回归模型了，咱们怎么去拟合一个合适的 $\theta$ 呢？我们之前已经看到了在一系列前提下，最小二乘法回归可以通过最大似然估计来推出，那么接下来就给我们这个分类模型做一系列的统计学假设，然后用最大似然法拟合参数&lt;/p&gt;
&lt;p&gt;首先假设：
&lt;/p&gt;
$$
P(y = 1 \mid x;\theta) = h_\theta(x)
$$$$
P(y = 0 \mid x;\theta) = 1 - h_\theta(x)
$$&lt;p&gt;更简洁的写法是：&lt;/p&gt;
$$
p(y \mid x;\theta) = (h_\theta(x))^{y}\,(1 - h_\theta(x))^{1 - y}
$$&lt;p&gt;
假设m个训练样本都是各自独立生成的，那么就可以按如下的方式来写参数的似然函数：
&lt;/p&gt;
$$
\begin{aligned}
L(\theta) &amp;= p(\vec{y} \mid X; \theta) \\
&amp;= \prod_{i=1}^{m} p(y^{(i)} \mid x^{(i)}; \theta) \\
&amp;= \prod_{i=1}^{m} \left( h_\theta(x^{(i)})^{\,y^{(i)}} \, (1 - h_\theta(x^{(i)}))^{\,1 - y^{(i)}} \right)
\end{aligned}
$$&lt;p&gt;
然后和之前一样，取个对数就很容易计算最大值
&lt;/p&gt;
$$
\begin{aligned}
\ell(\theta) &amp;= \log L(\theta) \\
&amp;= \sum_{i=1}^{m}\Big( y^{(i)} \log h(x^{(i)}) + \big(1 - y^{(i)}\big)\log\big(1 - h(x^{(i)})\big) \Big)
\end{aligned}
$$&lt;p&gt;
怎么让似然函数最大？就跟之前在线性回归的时候用了求导数的方法类似，咱们这次就是用&lt;strong&gt;梯度上升法&lt;/strong&gt;。还是写成向量的形式，然后更新，就是$\theta := \theta + \alpha \nabla_{\theta}\ell(\theta)$。（因为找最大值，所以是加号），还是先从只有一组训练样本(x,y)开始，然后求导数来退出随机梯度上升规则：
&lt;/p&gt;
$$
\begin{aligned}
\frac{\partial}{\partial \theta_j}\ell(\theta)
&amp;= \left( y \frac{1}{g(\theta^T x)} - (1-y)\frac{1}{1-g(\theta^T x)} \right)
\frac{\partial}{\partial \theta_j} g(\theta^T x) \\
&amp;= \left( y \frac{1}{g(\theta^T x)} - (1-y)\frac{1}{1-g(\theta^T x)} \right)
g(\theta^T x)\bigl(1-g(\theta^T x)\bigr)\,
\frac{\partial}{\partial \theta_j}\theta^T x \\
&amp;= \Bigl( y\bigl(1-g(\theta^T x)\bigr) - (1-y)g(\theta^T x) \Bigr)\,x_j \\
&amp;= \bigl( y - h_\theta(x) \bigr)\,x_j
\end{aligned}
$$&lt;p&gt;上面的式子里，我们用到了对函数求导的定理$g&amp;rsquo;(z)=g(z)(1-g(z))$。然后就用到了随机梯度上升规则：
&lt;/p&gt;
$$
\theta_j := \theta_j + \alpha\bigl(y^{(i)}-h_\theta(x^{(i)})\bigr)x_j^{(i)}
$$&lt;p&gt;
如果我们将其和 &lt;strong&gt;LMS&lt;/strong&gt; 更新规则相对比，就能发现看上去挺相似的；&lt;strong&gt;不过这并不是同一个算法&lt;/strong&gt;，因为这里的$h_0(x^{(i)})$现在定义成了一个$\theta^Tx^{(i)}$的非线性函数尽管如此，我们面对不同的学习问题使用了不同的算法，却得到了看上去一样的更新规则，这是巧合吗，我们学到GLM广义线性模型的时候就会得到答案了。&lt;/p&gt;
&lt;h2 id="题外话感知器学习算法"&gt;题外话：感知器学习算法
&lt;/h2&gt;&lt;p&gt;现在简单聊一个算法，它的历史很有趣，并且之后讲学习理论的时候还要讲到它。设想一下，对逻辑回归方法修改一下，“强迫” 它输出的值要么是0要么是1。要实现这个目的，很自然就应该把函数 $g$ 的定义修改一下，改成一个阙值函数
&lt;/p&gt;
$$
g(z)=
\begin{cases}
1, &amp; z \ge 0 \\
0, &amp; z &lt; 0
\end{cases}
$$&lt;p&gt;
若是我们还像之前一样令 $h_\theta(x)=g(\theta^Tx)$，但用刚刚上面的阙值函数作为 $g$ 的定义，然后如果我们用了下面的更新规则：
&lt;/p&gt;
$$
\theta_j := \theta_j + \alpha(y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}
$$&lt;p&gt;
这样我们就得到了感知器学习算法&lt;/p&gt;</description></item><item><title>CS229作业0</title><link>https://lunatide.tech/p/cs229%E4%BD%9C%E4%B8%9A0/</link><pubDate>Sat, 06 Dec 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229%E4%BD%9C%E4%B8%9A0/</guid><description>&lt;img src="https://lunatide.tech/p/cs229%E4%BD%9C%E4%B8%9A0/pic1.jpg" alt="Featured image of post CS229作业0" /&gt;&lt;h2 id="1-gradients-and-hessians"&gt;1. Gradients and Hessians
&lt;/h2&gt;&lt;h3 id="a"&gt;a.
&lt;/h3&gt;&lt;p&gt;由第一项，我们可以得到：&lt;/p&gt;
$$
f_1(x) = \frac{1}{2} x^T A x + b^T x
$$&lt;p&gt;因为：&lt;/p&gt;
$$
\nabla_x(x^T A x) = (A + A^T)x
$$&lt;p&gt;因此：&lt;/p&gt;
$$
\nabla_x\left( \frac{1}{2} x^T A x \right)
= \frac{1}{2}(A + A^T)x
$$&lt;p&gt;因为 \(A\) 是对称矩阵（\(A^T = A\)），所以：&lt;/p&gt;
$$
\frac{1}{2}(A + A)x = Ax
$$&lt;p&gt;第二项：&lt;/p&gt;
$$
f_2(x) = b^T x = \sum_i b_i x_i
$$&lt;p&gt;梯度为：&lt;/p&gt;
$$
\nabla_x(b^T x) = b
$$&lt;p&gt;因此：&lt;/p&gt;
$$
\nabla f(x) = Ax + b
$$&lt;h3 id="b"&gt;b.
&lt;/h3&gt;&lt;p&gt;令 \(z = h(x)\)，则：&lt;/p&gt;
$$
f(x) = g(z) = g(h(x))
$$&lt;p&gt;对每个分量有：&lt;/p&gt;
$$
\frac{\partial f}{\partial x_i}
= g'(h(x)) \frac{\partial h(x)}{\partial x_i}
$$&lt;p&gt;因此：&lt;/p&gt;
&lt;div&gt;
$$
\nabla f(x)
=
\begin{pmatrix}
g'(h(x)) \frac{\partial h}{\partial x_1} \\
g'(h(x)) \frac{\partial h}{\partial x_2} \\
\vdots \\
g'(h(x)) \frac{\partial h}{\partial x_n}
\end{pmatrix}
=
g'(h(x)) \nabla h(x)
$$
&lt;/div&gt;
&lt;h3 id="c"&gt;c.
&lt;/h3&gt;&lt;p&gt;由 a 得：&lt;/p&gt;
$$
(\nabla f(x))_i
= \sum_{j=1}^n a_{ij} x_j + b_i
$$&lt;p&gt;Hessian 的第 \(i, j\) 项为：&lt;/p&gt;
&lt;div&gt;
$$
(\nabla^2 f(x))_{ij}
=
\frac{\partial}{\partial x_j}
\left(
\sum_{k=1}^n a_{ik} x_k + b_i
\right)
$$
&lt;/div&gt;
&lt;p&gt;利用：&lt;/p&gt;
$$
\frac{\partial}{\partial x_j}(a_{ik} x_k)
= a_{ik}\delta_{kj}
$$&lt;p&gt;所以：&lt;/p&gt;
$$
(\nabla^2 f(x))_{ij}
= \sum_{k=1}^n a_{ik}\delta_{kj}
= a_{ij}
$$&lt;p&gt;因此：&lt;/p&gt;
$$
\nabla^2 f(x) = A
$$</description></item><item><title>CS229 Lecture 2</title><link>https://lunatide.tech/p/cs229-lecture-2/</link><pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cs229-lecture-2/</guid><description>&lt;img src="https://lunatide.tech/p/cs229-lecture-2/pic1.jpg" alt="Featured image of post CS229 Lecture 2" /&gt;&lt;h2 id="线性回归"&gt;线性回归
&lt;/h2&gt;&lt;p&gt;有如下数据集&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/cs229-lecture-2/p1.jpg"
width="826"
height="326"
srcset="https://lunatide.tech/p/cs229-lecture-2/p1_hu_6de0275242601ffb.jpg 480w, https://lunatide.tech/p/cs229-lecture-2/p1_hu_f210478988d82bd6.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="253"
data-flex-basis="608px"
&gt;&lt;/p&gt;
&lt;p&gt;在上图中，输入特征$x$是$\mathbb{R}^2$范围取值的一个二维向量，$x_1^{(i)}$就是训练集中第$i$个房屋的面积，而$x_2^{(i)}$就是训练集中第$i$个房屋的我是数量，这只是举个例子，设计算法的时候你可以自己设计特征量&lt;/p&gt;
&lt;p&gt;然后我们可以把$y$假设为一个以$x$为变量的线性函数
&lt;/p&gt;
$$
h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2
$$&lt;p&gt;
这里的$\theta_i$是参数，也叫权重，是从$X$到$Y$的线性函数映射的空间参数，在不引起混淆的情况下可以把$h_\theta(x)$中的$\theta$省略，另外，为了简化我们设$x_0=1$，简化后就有
&lt;/p&gt;
$$
h(x)=\sum_{i=0}^{n} \theta x_i=\theta^T x
$$&lt;p&gt;
等式最右边的$\theta$和$x$都是向量，$x$是输入变量的个数（就是特征量个数）&lt;/p&gt;
&lt;p&gt;现在，给定了一个&lt;strong&gt;训练集&lt;/strong&gt;，我们该如何挑选参数$\theta$，一个看上去比较合理的方法是让$h(x)$尽量逼近$y$,若是要用公式的形式来表示，就要定义一个函数，由此来衡量对于每个不同的$\theta$值，$h(x^{(i)})$与对应的$y^{(i)}$的距离，用如下的方式定义了一个&lt;strong&gt;成本函数&lt;/strong&gt;
&lt;/p&gt;
$$
J(\theta)=\frac{1}{2}\sum_{i=1}^{n}{(h_\theta(x^{(i)})-y^{(i)})^2}
$$&lt;p&gt;
你会发现这个函数和常规最小二乘法拟合模型中的最小二乘法成本函数非常相似&lt;/p&gt;
&lt;h3 id="最小均方算法lms"&gt;最小均方算法(LMS)
&lt;/h3&gt;&lt;p&gt;我们要让$J(\theta)$最小，我们考虑用&lt;strong&gt;梯度下降法&lt;/strong&gt;，这个方法就是从某一个$\theta$的初始值开始，然后逐渐重复更新
&lt;/p&gt;
$$
\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j} J{(\theta)}
$$&lt;p&gt;
在这个式子中，$\alpha$是&lt;strong&gt;学习率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要实现这个算法，我们要知道右边的导数项是什么，让我们来计算一下
&lt;/p&gt;
$$
\begin{align*}
\frac{\partial}{\partial \theta_j} J(\theta)
&amp;= \frac{\partial}{\partial \theta_j} \frac{1}{2}(h_\theta(x) - y)^2 \\[6pt]
&amp;= (h_\theta(x) - y)\, \frac{\partial}{\partial \theta_j}(h_\theta(x) - y) \\[6pt]
&amp;= (h_\theta(x) - y)\, \frac{\partial}{\partial \theta_j}\left(\sum_{i=0}^n \theta_i x_i - y\right) \\[6pt]
&amp;= (h_\theta(x) - y)\, x_j
\end{align*}
$$&lt;p&gt;对单个训练样本，更新规则如下：&lt;/p&gt;
$$
\theta_j := \theta_j + \alpha \left( y^{(i)} - h_\theta(x^{(i)}) \right) x_j^{(i)}
$$&lt;p&gt;
这个规则也称为&lt;strong&gt;LMS&lt;/strong&gt;更新规则，也称为&lt;strong&gt;Widrow-Hoff&lt;/strong&gt;学习规则，具体的算法如下&lt;/p&gt;
&lt;p&gt;重复直到收敛{&lt;/p&gt;
&lt;p&gt;对每个$j$:
&lt;/p&gt;
$$
\theta_j:=\theta_j+\alpha\sum_{i=1}^m{(y^{(i)}-h_\theta(x^{(i)}))}
$$&lt;p&gt;
}&lt;/p&gt;
&lt;p&gt;这个方法叫做&lt;strong&gt;批量梯度下降法(batch gradient descent)&lt;/strong&gt;，此外还有一种方法&lt;/p&gt;
&lt;p&gt;Loop{&lt;/p&gt;
&lt;p&gt;​ for i=1 to m{&lt;/p&gt;
&lt;p&gt;​ 对每个$j$:
&lt;/p&gt;
$$
\theta_j := \theta_j + \alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
$$&lt;p&gt;​ }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个算法叫做&lt;strong&gt;随机梯度下降法(SGD)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在批量梯度下降算法中，我们要扫描整个训练集，才会更新一次，当数据集的量非常庞大的时候，会有很大计算量，而随机梯度下降算法在遇到训练样本的时候仅根据该单个训练样本的误差梯度更新参数，所以随机梯度下降往往比批量梯下降更快接近最小值。&lt;/p&gt;
&lt;p&gt;注意，它可能不会收敛到最小值，$\theta$会在$J(\theta)$的最小值附近震荡&lt;/p&gt;
&lt;h3 id="正规方程"&gt;正规方程
&lt;/h3&gt;&lt;p&gt;这是第二种方法，这种方法中我们通过求导让导数等于0的方式找到取得最小值的地方，给定一个训练集，把设计矩阵$X$设置为一个$x*n$的矩阵(实际上是$m * (n + 1)$，如果包含截距项)，该矩阵的每行是个训练样本
&lt;/p&gt;
$$
X =
\begin{bmatrix}
-(x^{(1)})^{T}- \\
-(x^{(2)})^T- \\
\vdots \\
-(x^{(m)})^T-
\end{bmatrix}
$$&lt;p&gt;另外，令 $\vec{y}$ 为包含训练集中所有目标值的 $m$ 维向量：&lt;/p&gt;
$$
\vec{y} =
\begin{bmatrix}
y^{(1)} \\
y^{(2)} \\
\vdots \\
y^{(m)}
\end{bmatrix}
$$&lt;p&gt;由于 $h_\theta(x^{(i)}) = (x^{(i)})^T \theta$，我们可以很容易地验证：&lt;/p&gt;
&lt;div&gt;
$$
X\theta - \vec{y} =
\begin{pmatrix}
(x^{(1)})^T\theta \\\
\vdots \\\
(x^{(m)})^T\theta
\end{pmatrix}
-
\begin{pmatrix}
y^{(1)} \\\
\vdots \\\
y^{(m)}
\end{pmatrix}
=
\begin{pmatrix}
(x^{(1)})^T\theta - y^{(1)} \\\
\vdots \\\
(x^{(m)})^T\theta - y^{(m)}
\end{pmatrix}
$$
&lt;/div&gt;
对于向量 $z$，则有 $z^T z = z^2$，因此利用这个性质，可以推导出：
$$
\begin{align*}
\frac{1}{2}(X\theta - \vec{y})^T (X\theta - \vec{y})
&amp;= \frac{1}{2} \sum_{i=1}^{m} \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2
= J(\theta)
\end{align*}
$$&lt;p&gt;
关于$\theta$求梯度我们就可以得到：
&lt;/p&gt;
$$
\begin{align*}
\nabla_\theta J(\theta)
&amp;= \nabla_\theta \frac{1}{2} (X\theta - \vec{y})^T (X\theta - \vec{y}) \\[6pt]
&amp;= \frac{1}{2} \nabla_\theta (\theta^T X^T X \theta - \theta^T X^T \vec{y} - \vec{y}^T X \theta + \vec{y}^T \vec{y}) \\[6pt]
&amp;= \frac{1}{2} \nabla_\theta (\theta^T X^T X \theta - 2\theta^T X^T \vec{y}) \\[6pt]
&amp;= \frac{1}{2} (2 X^T X \theta - 2 X^T \vec{y}) \\[6pt]
&amp;= X^T X \theta - X^T \vec{y}
\end{align*}
$$&lt;p&gt;
第四个等号利用了&lt;/p&gt;
$$
\nabla_\theta (\theta^T A \theta) = (A + A^T)\theta
$$$$
\nabla_\theta (\theta^T x) = x
$$&lt;p&gt;令梯度为 0 可得 &lt;strong&gt;正规方程&lt;/strong&gt;：&lt;/p&gt;
$$
X^T X \theta = X^T \vec{y}
$$&lt;p&gt;因此，通过等式以解析形式给出使$J(\theta)$最小化的 $\theta$ 的值：&lt;/p&gt;
$$
\theta = (X^T X)^{-1} X^T \vec{y}
$$</description></item></channel></rss>