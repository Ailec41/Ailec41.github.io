<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ICPC Training on LunaTide's Blog</title><link>https://ailec41.github.io/categories/icpc-training/</link><description>Recent content in ICPC Training on LunaTide's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LunaTide's Blog</copyright><lastBuildDate>Thu, 09 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ailec41.github.io/categories/icpc-training/index.xml" rel="self" type="application/rss+xml"/><item><title>ICPC日常训练01</title><link>https://ailec41.github.io/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/</link><pubDate>Thu, 09 Oct 2025 00:00:00 +0000</pubDate><guid>https://ailec41.github.io/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/</guid><description>&lt;img src="https://ailec41.github.io/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/codeforce_%E5%89%AF%E6%9C%AC.jpg" alt="Featured image of post ICPC日常训练01" /&gt;&lt;p&gt;日常的训练，回顾一下做的几道题，算是思维题专场&lt;/p&gt;
&lt;p&gt;*&lt;em&gt;CF2056D Unique Median &lt;em&gt;2200&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;给了一个整数数组b，当排序后满足$b⌊\frac{m+1}{2}⌋=b⌈\frac{m+1}{2}⌉$时我们说数组是好的，题目说给一个长度为n的数组a，计算好子数组数量&lt;/p&gt;
&lt;p&gt;首先观察好数组定义，我们可以很容易发现奇数长度的数组一定是好数组，所以我们只要看偶数长度的数组就可以了，很困难，想了一段时间，一开始的想法是如果我们要让偶数的数组是好的，那么当且仅当存在某个数$v$，使得在选取的子数组中$v \ge m/2$，也就是说至少一半都是同一个数，但是肯定会有重复用容斥修正，减掉重复的就可以，实现很麻烦，写了很久，而且还发现是错误的，对于[1,1,2,3]按照这个思路明显错的，而且发现正着处理非常麻烦困难，于是决定反向试试，从所有子数组中减掉&amp;quot;坏的&amp;quot;，再修正&lt;/p&gt;
&lt;p&gt;很快就发现了一些东西，对于一个偶数的数组，只要让排序后第k个数小于k+1个数一定是坏的，再具体点，我们选定两个相邻的数x，y，我们只要让左中位数小于等于x，右中位数大于等于y就可以了，然后用&lt;strong&gt;前缀和+map即可&lt;/strong&gt;，并且小于等于x的数的数量和大于等于y的数字数量必须要一样多，那么我们可以把数组按照值分为3类，一种小于等于x我们记为-1，大于等于y记为+1，介于x和y之间的我们直接清空，因为出现就相当于直接破坏了我们的数组&lt;/p&gt;
&lt;p&gt;最后就是用容斥进行修正，只要x和y相差超过2就记为重复的减掉就可以了&lt;/p&gt;
&lt;p&gt;*&lt;em&gt;CF1841E Fill the Matrix &lt;em&gt;2200&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;*&lt;em&gt;CF1854A2 Dual (Hard Version) &lt;em&gt;1900&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一道思维题，给了一个数组，可以对于$i,j$的元素进行操作，使得$a_i := a_i + a_j$&lt;/p&gt;
&lt;p&gt;要求在31次操作内让数组不递减&lt;/p&gt;
&lt;p&gt;首先当所有元素都大于等于0或者全部都小于等于0的时候很显然，我们只需要把右边的数依次加上左边的数肯定是对的（小于等于0同理反过来就行）&lt;/p&gt;
&lt;p&gt;所以关键是要看数组里有正有负，我们设最大的正数是mx，绝对值最大的负数是mi，正数数量是cp，负数数量是cm，那么我们有两种选择，一种是都统一成非负，一种是统一成非正，只要符号统一我们就方便了，拿统一非负举例（非正同理），我们其实就是要让最大的正数足够大，能够覆盖所有负数，我们首先计算mx经过几次翻倍可以大于mi，然后让他翻倍，之后让所有的负数都加上这个mx它们都变成正数了，然后我们就判断一下这两种选择哪个更优即可&lt;/p&gt;
&lt;p&gt;、&lt;/p&gt;</description></item></channel></rss>