<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Sicence on LunaTide's Blog</title><link>https://ailec41.github.io/categories/computer-sicence/</link><description>Recent content in Computer Sicence on LunaTide's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LunaTide's Blog</copyright><lastBuildDate>Wed, 24 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ailec41.github.io/categories/computer-sicence/index.xml" rel="self" type="application/rss+xml"/><item><title>lecture02 bits,bytes and integer</title><link>https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/</link><pubDate>Wed, 24 Sep 2025 00:00:00 +0000</pubDate><guid>https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/</guid><description>&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/csapp.jpg" alt="Featured image of post lecture02 bits,bytes and integer" /&gt;&lt;h2 id="bits"&gt;Bits
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么要用比特&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于用双稳态元件存储&lt;/li&gt;
&lt;li&gt;能在有噪声且不精确的电线上可靠传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits.jpg"
width="796"
height="249"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits_hu_db0e1589287f0e6f.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits_hu_544ef48d82bcf07.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
&gt;&lt;/p&gt;
&lt;p&gt;我们可以用二进制来表示浮点数。在一个二进制的小数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、…&lt;/li&gt;
&lt;li&gt;小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding.jpg"
width="1970"
height="1236"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding_hu_90858520df601cc9.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding_hu_c9b2f1c44445d012.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个字节等于 8 比特&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="布尔代数"&gt;布尔代数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;比特之间的关系（操作）&lt;/li&gt;
&lt;li&gt;1 代表 true，0 代表 false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan.jpg"
width="1454"
height="716"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan_hu_47fd8da15e9935a9.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan_hu_b0cc73e741231d31.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="203"
data-flex-basis="487px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example：表示与操作集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示方式：
&lt;ul&gt;
&lt;li&gt;一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集&lt;/li&gt;
&lt;li&gt;如果 $a_j = 1，j ∈ A$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for example：{0, 3, 5, 6}
&lt;ul&gt;
&lt;li&gt;01101001&lt;/li&gt;
&lt;li&gt;76543210&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。&lt;/p&gt;
&lt;h3 id="对比逻辑运算符"&gt;对比逻辑运算符
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&amp;amp;、||、 !&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!0x41 → 0x00&lt;/li&gt;
&lt;li&gt;!0x99 → 0x01&lt;/li&gt;
&lt;li&gt;!!ox41 → 0x01&lt;/li&gt;
&lt;li&gt;0x69 &amp;amp;&amp;amp; 0x55 → 0x01&lt;/li&gt;
&lt;li&gt;p &amp;amp;&amp;amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="移位操作"&gt;移位操作
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;左移：x &amp;laquo; y&lt;/strong&gt;&lt;/p&gt;</description></item></channel></rss>