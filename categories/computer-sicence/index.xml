<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Sicence on LunaTide's Blog</title><link>https://ailec41.github.io/categories/computer-sicence/</link><description>Recent content in Computer Sicence on LunaTide's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LunaTide's Blog</copyright><lastBuildDate>Sun, 28 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ailec41.github.io/categories/computer-sicence/index.xml" rel="self" type="application/rss+xml"/><item><title>Lab1 DataLab</title><link>https://ailec41.github.io/p/lab1-datalab/</link><pubDate>Sun, 28 Sep 2025 00:00:00 +0000</pubDate><guid>https://ailec41.github.io/p/lab1-datalab/</guid><description>&lt;img src="https://ailec41.github.io/p/lab1-datalab/csapp.jpg" alt="Featured image of post Lab1 DataLab" /&gt;</description></item><item><title>lecture03 Bits,Bytes and Integer cout</title><link>https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/</link><pubDate>Fri, 26 Sep 2025 00:00:00 +0000</pubDate><guid>https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/</guid><description>&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/csappp.jpg" alt="Featured image of post lecture03 Bits,Bytes and Integer cout" /&gt;&lt;h2 id="加法"&gt;加法
&lt;/h2&gt;&lt;h3 id="无符号加法"&gt;无符号加法
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/addition.jpg"
width="1902"
height="1160"
srcset="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/addition_hu_716bbff97dd22ccf.jpg 480w, https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/addition_hu_e5b30f30f868aa0e.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
&gt;&lt;/p&gt;
&lt;p&gt;无符号的加法很简单，和二进制加法一样，只不过要把overflow的删除，并且把结果取模即可&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/visualizing.jpg"
width="1072"
height="1038"
srcset="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/visualizing_hu_f2f3910ed996a27e.jpg 480w, https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/visualizing_hu_c860ff4384a3d7c5.jpg 1024w"
loading="lazy"
alt="可视化整数加法图"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
&gt;&lt;/p&gt;
&lt;p&gt;![可视化无符号加法图](截屏2025-09-28 15.51.13.jpg)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测无符号数中加法的溢出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 $s = U +_w^u V$ 为无符号整数 $U$ 和 $V$ 的和，那么当且仅当 $s &amp;lt; U$（或等价的 $s &amp;lt; V$）时产生溢出，这是因为：&lt;/p&gt;
$$
\begin{aligned}
s &amp;= U + V - 2^w &lt; U \\
s &amp;= U + V - 2^w &lt; V
\end{aligned}
$$&lt;h2 id="补码加法"&gt;补码加法
&lt;/h2&gt;&lt;p&gt;![](截屏2025-09-28 15.57.52.jpg)&lt;/p&gt;
&lt;p&gt;对满足 $-2^{w-1} \leq x$，$y \leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：&lt;/p&gt;
$$
x +_w^t y =
\begin{cases}
x + y - 2^w, &amp; 2^{w-1} \leq x + y \quad \text{正溢出} \\
x + y, &amp; -2^{w-1} \leq x + y &lt; 2^{w-1} \quad \text{正常} \\
x + y + 2^w, &amp; x + y &lt; -2^{w-1} \quad \text{负溢出}
\end{cases}
$$&lt;p&gt;
两个数的$w$位补码之和与无符号之和有完全相同的位级表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用左移做乘法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数机器中左移比乘法快
&lt;ul&gt;
&lt;li&gt;编译器会自动生成这样的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法的证明：&lt;/p&gt;
&lt;p&gt;假设 $x$ 的 $w$ 位二进制表示为 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$，那么 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}, 0, \cdots, 0\right]$ 给出了 $x2^k$ 的 $w+k$ 位二进制表示：&lt;/p&gt;
$$
\begin{aligned}
B2U_{w+k}\left(\left[x_{w-1}, x_{w-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) &amp;= \sum_{i=0}^{w-1} x_{i} 2^{i+k} \\
&amp;= \left[\sum_{i=0}^{w-1} x_{i} 2^{i}\right] \cdot 2^{k} \\
&amp;= x 2^{k}
\end{aligned}
$$&lt;p&gt;对于固定长度的表示，高 $k$ 位被丢弃，左移 $k$ 位的二进制表示为
&lt;/p&gt;
$$
\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]
$$&lt;p&gt;所以
&lt;/p&gt;
$$
\begin{aligned}
B2U_{w}\left(\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) &amp;= \sum_{i=0}^{w-k-1} x_{i} 2^{i+k} \\
&amp;= \left[\sum_{i=0}^{w-k-1} x_{i} 2^{i}\right] \cdot 2^{k} \\
&amp;= \left[\sum_{i=0}^{w-1} x_{i} 2^{i}\right] \cdot 2^{k} \mod 2^w \\
&amp;= x2^k \mod 2^w
\end{aligned}
$$&lt;p&gt;所以对于无符号整数
&lt;/p&gt;
$$
B2U_{w}\left(\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) = \text{UMult}_w(x,2^k)
$$&lt;p&gt;对于有符号整数，利用
&lt;/p&gt;
$$
\text{TMult}_w(u,v) = U2T_w((u \cdot v) \mod 2^w)
$$&lt;p&gt;
可以得到相同的结果。&lt;/p&gt;
&lt;p&gt;一般情形&lt;/p&gt;
&lt;p&gt;现在考虑一般的情形，假设我们需要计算 $u \times K$，其中 $K$ 为常数，将 $K$ 表达为一组 $0$ 和 $1$ 交替的序列
&lt;/p&gt;
$$
[(0 \cdots 0)(1 \cdots 1)(0 \cdots 0) \cdots (1 \cdots 1)]
$$&lt;p&gt;考虑一组从位置 $n$ 到位置 $m$ 的连续 $1$，那么可以用如下方式计算这部分的对于乘积的影响：
&lt;/p&gt;
$$
\begin{aligned}
&amp;(x &lt;&lt; n) + (x &lt;&lt; (n-1)) + \cdots + (x &lt;&lt; m) \\
&amp;(x &lt;&lt; (n+1)) - (x &lt;&lt; m)
\end{aligned}
$$&lt;h2 id="移位操作和二进制乘除法的联系"&gt;移位操作和二进制乘除法的联系
&lt;/h2&gt;&lt;h3 id="使用移位操作代替除以-2-的幂无符号"&gt;使用移位操作代替除以 2 的幂（无符号）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$u &amp;raquo; k$ 给出 $\lfloor u / 2^{k} \rfloor$&lt;/li&gt;
&lt;li&gt;使用逻辑移位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/mul.jpg"
width="958"
height="268"
srcset="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/mul_hu_8caa170d186c95.jpg 480w, https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/mul_hu_f99fbeb6eb694c06.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="857px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 $x$ 的 $w$ 位二进制表示为 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$，右移 $k$ 位的二进制表示为 $\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]$&lt;/p&gt;
$$
\begin{aligned}
B2U_w(\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]) &amp;= \sum_{i=0}^{w-k-1} x_{i+k} 2^{i} \\
B2U_{w}\left(\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]\right) &amp;= \sum_{i=0}^{w-1} x_{i} 2^{i} \\
&amp;= 2^k \sum_{i=0}^{w-k-1} x_{i+k} 2^{i} + \sum_{i=0}^{k-1} x_{i} 2^{i} \\
&amp;= 2^k B2U_w(\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]) + \sum_{i=0}^{k-1} x_{i} 2^{i}
\end{aligned}
$$&lt;p&gt;所以
&lt;/p&gt;
$$
\lfloor x / 2^{k} \rfloor = x &gt;&gt; k
$$&lt;h3 id="使用移位操作代替除以-2-的幂有符号"&gt;使用移位操作代替除以 2 的幂（有符号）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$u &amp;raquo; k$ 给出 $\lfloor u / 2^{k} \rfloor$&lt;/li&gt;
&lt;li&gt;使用算数移位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 $u &amp;gt; 0$ 时上述方法和无符号情形一致，但是当 $u &amp;lt; 0$ 时则会产生有问题的结果，例如取 $u = -12340$：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/power.jpg"
width="946"
height="330"
srcset="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/power_hu_d9c418a63cbd7841.jpg 480w, https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/power_hu_52ca23a0fce2f661.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
&gt;&lt;/p&gt;
&lt;p&gt;考虑 $k=4,8$ 时的结果，在 C 语言中实际结果为 $-771$ 和 $-48$，之所以和 C 语言中的结果不同，是因为上述算法朝着离 $0$ 更远的方向舍入，所以当 $u &amp;lt; 0$ 时要向上舍入，达到上述效果利用如下事实即可
&lt;/p&gt;
$$
\lceil x / y \rceil = \lfloor (x + y - 1) / y \rfloor
$$&lt;h2 id="unsigned"&gt;Unsigned
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须做一个明确的分配而不是暗示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易犯错误，例如下面的代码会出现无限循环&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;unsigend&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可能会变的很诡异&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define DELTA sizeof(int)&lt;/span&gt;&lt;span class="c1"&gt;//默认int的size是一个unsigned的size_t
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CNT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;DELTA&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;DELTA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//和上面的代码出现一样的问题
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正确的代码如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;什么时候用无符号整数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行模块化算术时使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多精度算术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用位表示集时使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑右移，无符号扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（最好不要用unsigned）&lt;/p&gt;
&lt;h2 id="内存中数字的一些底层表示"&gt;内存中数字的一些底层表示
&lt;/h2&gt;&lt;h3 id="word-size"&gt;Word Size
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件本身并不一定定义字长大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何给定的计算机都具有字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直到现在，大部份机器都采用32 bits(4 bytes)作为字长&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址限制为4 GB($2^{32}$bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;越来越多机器具有64位字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器仍然支持多种数据格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字长的分数或整数倍&lt;/li&gt;
&lt;li&gt;但总是整数比特&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/2020050814.jpg"
width="416"
height="626"
srcset="https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/2020050814_hu_236969b163c8f936.jpg 480w, https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/2020050814_hu_5c8827325c770696.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="159px"
&gt;&lt;/p&gt;
&lt;h3 id="比特顺序"&gt;比特顺序
&lt;/h3&gt;&lt;p&gt;分为大端法和小端法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Example
&lt;ul&gt;
&lt;li&gt;变量x的value是0x01234567&lt;/li&gt;
&lt;li&gt;地址是0x100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;![](截屏2025-09-29 11.17.43.jpg)&lt;/p&gt;</description></item><item><title>lecture02 Bits,Bytes and Integer</title><link>https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/</link><pubDate>Wed, 24 Sep 2025 00:00:00 +0000</pubDate><guid>https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/</guid><description>&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/csapp.jpg" alt="Featured image of post lecture02 Bits,Bytes and Integer" /&gt;&lt;h2 id="bits"&gt;Bits
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么要用比特&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于用双稳态元件存储&lt;/li&gt;
&lt;li&gt;能在有噪声且不精确的电线上可靠传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits.jpg"
width="796"
height="249"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits_hu_db0e1589287f0e6f.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/why-bits_hu_544ef48d82bcf07.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
&gt;&lt;/p&gt;
&lt;p&gt;我们可以用二进制来表示浮点数。在一个二进制的小数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、…&lt;/li&gt;
&lt;li&gt;小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding.jpg"
width="1970"
height="1236"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding_hu_90858520df601cc9.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/encoding_hu_c9b2f1c44445d012.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个字节等于 8 比特&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="布尔代数"&gt;布尔代数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;比特之间的关系（操作）&lt;/li&gt;
&lt;li&gt;1 代表 true，0 代表 false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan.jpg"
width="1454"
height="716"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan_hu_47fd8da15e9935a9.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/boolenan_hu_b0cc73e741231d31.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="203"
data-flex-basis="487px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example：表示与操作集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示方式：
&lt;ul&gt;
&lt;li&gt;一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集&lt;/li&gt;
&lt;li&gt;如果 $a_j = 1，j ∈ A$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for example：{0, 3, 5, 6}
&lt;ul&gt;
&lt;li&gt;01101001&lt;/li&gt;
&lt;li&gt;76543210&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。&lt;/p&gt;
&lt;h3 id="对比逻辑运算符"&gt;对比逻辑运算符
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&amp;amp;、||、 !&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!0x41 → 0x00&lt;/li&gt;
&lt;li&gt;!0x99 → 0x01&lt;/li&gt;
&lt;li&gt;!!ox41 → 0x01&lt;/li&gt;
&lt;li&gt;0x69 &amp;amp;&amp;amp; 0x55 → 0x01&lt;/li&gt;
&lt;li&gt;p &amp;amp;&amp;amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="移位操作"&gt;移位操作
&lt;/h2&gt;&lt;h3 id="左移x--y"&gt;左移：x &amp;laquo; y
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;向左移动位次，多余的bits扔掉，添加相对应数目的0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="右移x--y"&gt;右移：x &amp;raquo; y
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑右移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和左移类似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数右移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若第一个数为1，把原本填充的0改为填充1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="整数编码"&gt;整数编码
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数&lt;/p&gt;
&lt;p&gt;$B2U(X) = \sum_{i = 0}^{w-1} x_i \cdot 2^i $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码(Two&amp;rsquo;s Complement)&lt;/p&gt;
&lt;p&gt;$B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数值范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W = 16&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value Type&lt;/th&gt;
&lt;th&gt;Formula / Binary Pattern&lt;/th&gt;
&lt;th&gt;Decimal&lt;/th&gt;
&lt;th&gt;Hex&lt;/th&gt;
&lt;th&gt;Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Unsigned Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UMin&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;00000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UMax&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;W&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;td&gt;0xFFFF&lt;/td&gt;
&lt;td&gt;11111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Two&amp;rsquo;s Complement Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TMin&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;W-1&lt;/sup&gt; / 100&amp;hellip;0&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;0x8000&lt;/td&gt;
&lt;td&gt;10000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TMax&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;W-1&lt;/sup&gt; - 1 / 011&amp;hellip;1&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;td&gt;0x7FFF&lt;/td&gt;
&lt;td&gt;01111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Other Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;111&amp;hellip;1&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0xFFFF&lt;/td&gt;
&lt;td&gt;11111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;000&amp;hellip;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;00000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此我们可以得到一个关系如下：&lt;/p&gt;
&lt;p&gt;​ $TMin = TMax + 1$&lt;/p&gt;
&lt;p&gt;​ $UMax = 2 \times TMax + 1$&lt;/p&gt;
&lt;h3 id="转换"&gt;转换
&lt;/h3&gt;&lt;p&gt;有符号整型和无符号整型和十进制的转换关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/123.jpg"
width="398"
height="604"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/123_hu_6784bc7cf29f5567.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/123_hu_e942a054b6ee95f.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="158px"
&gt;&lt;/p&gt;
&lt;p&gt;显然上述转换是可逆的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\text{U2B}(x)=\text{B2U}^{-1}(x)$&lt;/li&gt;
&lt;li&gt;$\text{T2B}(x)=\text{B2T}^{-1}(x)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用复合关系可以得到有符号整型以及无符号整型的转换关系：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/111.jpg"
width="980"
height="420"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/111_hu_86e9a1bb8947973c.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/111_hu_40f3ead3eb4aaf9b.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="560px"
&gt;&lt;/p&gt;
&lt;p&gt;对于$\text {TMin} \leqslant x \leqslant \text{TMax}$
&lt;/p&gt;
$$
T 2 U_w(x)=\left\{\begin{array}{ll}
x+2^{w}, &amp; x&lt;0 \\
x, &amp; x \geqslant 0
\end{array}\right.
$$&lt;p&gt;
对于$0 \leqslant x \leqslant \text{UMax}$
&lt;/p&gt;
$$
U 2 T_{w}(u)=\left\{\begin{array}{ll}
u, &amp; u \leqslant \text{TMax} \\
u-2^{w}, &amp; u&gt;\text{TMax}
\end{array}\right.
$$&lt;p&gt;下图为补码到无符号数的转换关系&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/222.jpg"
width="2078"
height="1344"
srcset="https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/222_hu_c8b3373b4ae2d50.jpg 480w, https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/222_hu_334248bba9997460.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="371px"
&gt;&lt;/p&gt;
&lt;p&gt;C语言中的转换如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//显示转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;tx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;uy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//隐式转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;tx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;uy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="表达式求值规则"&gt;表达式求值规则
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;若单个表达式中&lt;strong&gt;同时出现无符号数与有符号数&lt;/strong&gt;，则&lt;strong&gt;有符号值会被隐式转换为无符号数&lt;/strong&gt;（包括比较运算 &lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;举例：W = 32 位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常量定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TMIN = -2,147,483,648&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TMAX = 2,147,483,647&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;常量 1&lt;/th&gt;
&lt;th&gt;常量 2&lt;/th&gt;
&lt;th&gt;实际类型&lt;/th&gt;
&lt;th&gt;关系&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;假&lt;/td&gt;
&lt;td&gt;两者均为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt; 被转成 &lt;code&gt;4294967295U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt; 被转成 &lt;code&gt;2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(unsigned)-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt; 被转成 &lt;code&gt;4294967294U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;前者 &amp;lt; 后者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(int)2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;后者溢出成 &lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="小结有符号与无符号强制转换的基本规则"&gt;小结：有符号与无符号强制转换的基本规则
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;位模式保持不变&lt;/strong&gt;&lt;br&gt;
强制转换时，内存中的 0/1 序列原样复制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;仅重新解释&lt;/strong&gt;&lt;br&gt;
同一段位模式，按目标类型（有符号或无符号）重新解读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可能产生“意外”&lt;/strong&gt;&lt;br&gt;
数值可能突然加上或减去 2^W（W 为位数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表达式中的混合类型&lt;/strong&gt;&lt;br&gt;
只要表达式里&lt;strong&gt;同时出现&lt;/strong&gt;&lt;code&gt;signed int&lt;/code&gt;与&lt;code&gt;unsigned int&lt;/code&gt; ，&lt;strong&gt;编译器会把 &lt;code&gt;signed int&lt;/code&gt; 隐式转换成 &lt;code&gt;unsigned int&lt;/code&gt;&lt;/strong&gt;，再参与运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="扩展截断"&gt;扩展，截断
&lt;/h2&gt;&lt;h3 id="扩展"&gt;扩展
&lt;/h3&gt;&lt;p&gt;无符号扩展至需要在前面的bits补0,有符号扩展如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定w-bit的有符号整型x&lt;/li&gt;
&lt;li&gt;将其转换为w+k-bit的有符号整型，值不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;p&gt;将符号位复制k份&lt;/p&gt;
&lt;p&gt;$X&amp;rsquo; = X_{w-1},\dots,X_{w-1},X_{w-1},X_{w-2},\dots,X_0$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;补码的符号扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义宽度为 $w$ 的位向量 $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ 和宽度为 $w&amp;rsquo;$ 的位向量 $\vec{x}&amp;rsquo; = [x&amp;rsquo;&lt;em&gt;{w&amp;rsquo;-1}, x&amp;rsquo;&lt;/em&gt;{w&amp;rsquo;-2}, \dots, x&amp;rsquo;&lt;em&gt;0]$，其中 $w&amp;rsquo; &amp;gt; w$。则$B2T_w(\vec{x}) = B2T&lt;/em&gt;{w&amp;rsquo;}(\vec{x}&amp;rsquo;)$，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码数值的符号扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令$w&amp;rsquo; = w + k$，我们想要证明的是
&lt;/p&gt;
$$
B2T_{w+k} ([x_{w-1}, \cdots, x_{w-1}, x_{w-2}, \cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
$$&lt;p&gt;下面的证明是对$k$进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了：
&lt;/p&gt;
$$
B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
$$&lt;p&gt;展开左边的表达式，得到：
&lt;/p&gt;
$$
\begin{aligned}
B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \cdots, x_0]) &amp;= -x_{w-1}2^w + \sum_{i=0}^{w-1}x_i2^i \\
&amp;= -x_{w-1}2^w + x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= -x_{w-1}(2^w - 2^{w-1}) + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
\end{aligned}
$$&lt;p&gt;我们使用的关键属性是$2^w - 2^{w-1} = 2^{w-1}$。因此，加上一个权值为$-2^w$的位，和将一个权值为 $-2^{w-1}$的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。&lt;/p&gt;
&lt;h3 id="截断"&gt;截断
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;无符号截断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原始 $w$ 位：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2U}_w(X)=\sum_{i=0}^{w-1} x_i\cdot2^i
$$&lt;p&gt;截断为 $k$ 位后：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2U}_k(X)=\sum_{i=0}^{k-1} x_i\cdot2^i = \mathrm{B2U}_w(X)\bmod 2^k
$$&lt;p&gt;&lt;strong&gt;推导&lt;/strong&gt;
&lt;/p&gt;
$$
\begin{aligned}
B2U_w([x_{w-1}, x_{w-2}, \cdots, x_0]) \mod 2^k &amp;= \left[ \sum_{i=0}^{w-1} x_i 2^i \right] \mod 2^k \\
&amp;= \left[ \sum_{i=0}^{k-1} x_i 2^i \right] \mod 2^k \\
&amp;= \sum_{i=0}^{k-1} x_i 2^i \\
&amp;= B2U_k([x_{k-1}, x_{k-2}, \cdots, x_0])
\end{aligned}
$$&lt;p&gt;&lt;strong&gt;有符号截断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原始 $w$ 位：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2T}_w(X)=-x_{w-1}\cdot2^{w-1}+\sum_{i=0}^{w-2} x_i\cdot2^i
$$&lt;p&gt;
截断为 $k$ 位后：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2T}_k(X)=-x_{k-1}\cdot2^{k-1}+\sum_{i=0}^{k-2} x_i\cdot2^i = \mathrm{U2T}_k\!\bigl(\mathrm{B2U}_w(X)\bmod 2^k\bigr)
$$</description></item></channel></rss>