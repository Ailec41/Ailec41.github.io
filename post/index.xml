<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on LunaTide's Blog</title><link>https://lunatide.tech/post/</link><description>Recent content in Posts on LunaTide's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LunaTide's Blog</copyright><lastBuildDate>Mon, 10 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://lunatide.tech/post/index.xml" rel="self" type="application/rss+xml"/><item><title>深度学习笔记-神经网络</title><link>https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 10 Nov 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid><description>&lt;h2 id="从感知机到神经网络"&gt;从感知机到神经网络
&lt;/h2&gt;&lt;h3 id="感知机回顾"&gt;感知机回顾
&lt;/h3&gt;&lt;p&gt;用图来表示神经网络，类比感知机，我们把左边的一列称为&lt;strong&gt;输入层&lt;/strong&gt;，最右边的称之为&lt;strong&gt;输出层&lt;/strong&gt;，中间的称为&lt;strong&gt;中间层&lt;/strong&gt;(也称为隐藏层，因为神经元肉眼看不见)，我们知道当感知机接受$x_1,x_2$两个输入信号，输出$y$时，可以用如下的数学式来表示
&lt;/p&gt;
$$
y =
\begin{cases}
0, &amp; b + w_1 x_1 + w_2 x_2 \le 0 \\
1, &amp; b + w_1 x_1 + w_2 x_2 &gt; 0
\end{cases}
$$&lt;p&gt;
$b$是偏置，用于控制神经元被激活的容易程度，而$w_1,w_2$是表示各个信号的权重的参数，用于控制各个信号的重要性&lt;/p&gt;
&lt;p&gt;我们现在可以通过调用一个函数来替代(1)中分case讨论的情况来简化(1)，改写成如下形式
&lt;/p&gt;
$$
y = h(b + w_1x_1+ w_2x_2)
$$$$
h(x) =
\begin{cases}
0, &amp; x \le 0 \\
1, &amp; x &gt; 0
\end{cases}
$$&lt;h3 id="激活函数引入"&gt;激活函数引入
&lt;/h3&gt;&lt;p&gt;刚才的h(x)把输入信号的总和转换成了输出信号，h(x)就被称为&lt;strong&gt;激活函数(activation function)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在进一步改写式(2)，写成如下形式
&lt;/p&gt;
$$
a = b + w_1x_1 + w_2x_2
$$$$
y = h(a)
$$&lt;p&gt;首先，式(4)计算加权输入信号的和偏置的总和，然后用(5)的h函数转换为输出&lt;/p&gt;
&lt;h2 id="激活函数"&gt;激活函数
&lt;/h2&gt;&lt;h3 id="sigmoid函数"&gt;sigmoid函数
&lt;/h3&gt;&lt;p&gt;神经网络中经常使用的一个激活函数就是&lt;strong&gt;sigmoid函数&lt;/strong&gt;
&lt;/p&gt;
$$
h(x)=\frac{1}{1+e^{-x}} \quad (\text{sigmoid function})
$$&lt;p&gt;
实际上，感知机和神经网络的主要区别就在于激活函数，其他方面基本都是一样的&lt;/p&gt;
&lt;h3 id="阶跃函数的实现"&gt;阶跃函数的实现
&lt;/h3&gt;&lt;p&gt;阶跃函数如(3)所示，当输入超过0时，输出1，否则输出0，可以用如下代码简单实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;step_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个代码中参数x只能接受实数。例如不允许&lt;code&gt;step_function(np.array([1.0,2.0]))&lt;/code&gt;，所以我们把它修改为支持NumPy数组的实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;step_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="阶跃函数的图形"&gt;阶跃函数的图形
&lt;/h3&gt;&lt;p&gt;接下来我们就用图来表示上面定义的阶跃函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pylab&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;step_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;step_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#y轴范围&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/figure1.jpg"
width="640"
height="480"
srcset="https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/figure1_hu_4edc352cb7851f7c.jpg 480w, https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/figure1_hu_893ac30a708dd13a.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
&gt;&lt;/p&gt;
&lt;h3 id="sigmoid函数的实现"&gt;sigmoid函数的实现
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sigmoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>CMU15445-Project01</title><link>https://lunatide.tech/p/cmu15445-project01/</link><pubDate>Sat, 25 Oct 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/cmu15445-project01/</guid><description>&lt;img src="https://lunatide.tech/p/cmu15445-project01/good.jpg" alt="Featured image of post CMU15445-Project01" /&gt;&lt;p&gt;四个Projects都做完了，但是还在刷Leaderboa，有空就update博客内容&lt;/p&gt;</description></item><item><title>计算几何专项</title><link>https://lunatide.tech/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A1%B9/</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A1%B9/</guid><description>&lt;img src="https://lunatide.tech/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A1%B9/codeforce_%E5%89%AF%E6%9C%AC.jpg" alt="Featured image of post 计算几何专项" /&gt;&lt;p&gt;&lt;a class="link" href="https://vjudge.net/problem/POJ-2318" title="POJ-2318"
target="_blank" rel="noopener"
&gt;POJ-2318&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ICPC日常训练01</title><link>https://lunatide.tech/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/</link><pubDate>Thu, 09 Oct 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/</guid><description>&lt;img src="https://lunatide.tech/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/codeforce_%E5%89%AF%E6%9C%AC.jpg" alt="Featured image of post ICPC日常训练01" /&gt;&lt;p&gt;日常的训练，回顾一下做的几道题，实现不发&lt;/p&gt;
&lt;h2 id="icpc-hangzhou-reginal-f-fuzzy-ranking"&gt;ICPC Hangzhou Reginal F Fuzzy Ranking
&lt;/h2&gt;&lt;p&gt;不太会做，看了一下题解，下面是看完题解后的思路&lt;/p&gt;
&lt;p&gt;直接为任意“前→后”对连边会太多，在同一排列中，只连相邻元素 $a_j\to a_{j+1}$ 即可：因为一条从前往后的有向路径已经能覆盖该排列中任意“前→后”的可达关系。对所有 $k$ 个排列加边&lt;/p&gt;
&lt;p&gt;对图做一次 Tarjan/Kosaraju缩点，得到每个学校所属的 SCC 编号bel[x]，以及按拓扑序逆序排列的分量列表 scc。把每个榜单按 bel重新映射成“分量编号序列”。&lt;/p&gt;
&lt;p&gt;在某个榜单中，原先相邻的两点之间有边，缩点后相同分量的编号在该榜单上必然连成一段。因此每个榜单都可以被切成若干段，每段恰好由同一个 SCC 的元素组成。这个性质让我们可以把任意区间 $[l,r]$ 拆解为：左端一个不完整段 + 中间若干完整段 + 右端一个不完整段。&lt;/p&gt;
&lt;p&gt;对每个榜单i:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Segment：对位置轴进行分段。令 Segment= (L, R) 表示pos所在的那段在该榜单上的左右端点下标。线性扫，遇到一段相同编号的区间 $[L,R]$ 就把这对端点填给其中的每个位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dp 前缀：统计从开头到位置 $j$ 为止、同段内能形成的“模糊对”数量。若 $j$ 落在段 $[L,R]$，新增的成对数等于该段里被纳入的元素个数减一，即 $j-L$。因此定义
&lt;/p&gt;
$$
dp[id][j] = dp[id][j-1] + (j-L).
$$&lt;p&gt;
这样任意区间 $[x,y]$ 的“在同一段内形成的对数”就能通过 $dp$ 差分 $dp[id][y]-dp[id][x]$ 得到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总计复杂度$O(nk)$&lt;/p&gt;
&lt;h2 id="cf1841e-fill-the-matrix"&gt;CF1841E Fill the Matrix
&lt;/h2&gt;&lt;p&gt;题目说有一个$n * n$的正方形矩阵，在第$i$列，前$a_i$个格子都是黑色，剩下的格子是白色，在矩阵放入1到m到整数，每个格子最多放一个且黑色格子不能放，定义美丽值为数字 $j$ 和 $j+1$ 位于&lt;strong&gt;同一行&lt;/strong&gt;，且 $j+1$ 位于 $j$ 的&lt;strong&gt;右边相邻的格子&lt;/strong&gt;，求放置m个整数后最大美丽值&lt;/p&gt;
&lt;p&gt;我们一定先选一个最长的白色格子全填进去，直到填满或者数不够。因为如果不继续填等于说最后填的那个数旁边的格子就浪费了，所以关键就在于要把所有行的白色连续横段都计算出来，按长度分组，记为cnt[n]，代表长度n的横段有几个，直接暴力扫迷线维护复杂度是$O(n^2)$的，直接炸了，所以我们用线段树来维护最大值和位置然后再分治来统计cnt数组，相当于构建一颗笛卡尔树，每次把区间按最大值分为左右两部分，统计每层能产生的白格段，最后用贪心计算答案就可以了，这样最后复杂度就控制在$O(nlogn)$&lt;/p&gt;
&lt;h2 id="cf2056d-unique-median-2200"&gt;CF2056D Unique Median 2200
&lt;/h2&gt;&lt;p&gt;给了一个整数数组b，当排序后满足$b⌊\frac{m+1}{2}⌋=b⌈\frac{m+1}{2}⌉$时我们说数组是好的，题目说给一个长度为n的数组a，计算好子数组数量&lt;/p&gt;
&lt;p&gt;首先观察好数组定义，我们可以很容易发现奇数长度的数组一定是好数组，所以我们只要看偶数长度的数组就可以了，很困难，想了一段时间，一开始的想法是如果我们要让偶数的数组是好的，那么当且仅当存在某个数$v$，使得在选取的子数组中$v \ge m/2$，也就是说至少一半都是同一个数，但是肯定会有重复用容斥修正，减掉重复的就可以，实现很麻烦，写了很久，而且还发现是错误的，对于[1,1,2,3]按照这个思路明显错的，而且发现正着处理非常麻烦困难，于是决定反向试试，从所有子数组中减掉&amp;quot;坏的&amp;quot;，再修正&lt;/p&gt;
&lt;p&gt;很快就发现了一些东西，对于一个偶数的数组，只要让排序后第k个数小于k+1个数一定是坏的，再具体点，我们选定两个相邻的数x，y，我们只要让左中位数小于等于x，右中位数大于等于y就可以了，然后用&lt;strong&gt;前缀和+map即可&lt;/strong&gt;，并且小于等于x的数的数量和大于等于y的数字数量必须要一样多，那么我们可以把数组按照值分为3类，一种小于等于x我们记为-1，大于等于y记为+1，介于x和y之间的我们直接清空，因为出现就相当于直接破坏了我们的数组&lt;/p&gt;
&lt;p&gt;最后就是用容斥进行修正，只要x和y相差超过2就记为重复的减掉就可以了&lt;/p&gt;
&lt;h2 id="cf1854a2--dual-hard-version"&gt;CF1854A2 Dual (Hard Version)
&lt;/h2&gt;&lt;p&gt;一道思维题，给了一个数组，可以对于$i,j$的元素进行操作，使得$a_i := a_i + a_j$&lt;/p&gt;
&lt;p&gt;要求在31次操作内让数组不递减&lt;/p&gt;
&lt;p&gt;首先当所有元素都大于等于0或者全部都小于等于0的时候很显然，我们只需要把右边的数依次加上左边的数肯定是对的（小于等于0同理反过来就行）&lt;/p&gt;
&lt;p&gt;所以关键是要看数组里有正有负，我们设最大的正数是mx，绝对值最大的负数是mi，正数数量是cp，负数数量是cm，那么我们有两种选择，一种是都统一成非负，一种是统一成非正，只要符号统一我们就方便了，拿统一非负举例（非正同理），我们其实就是要让最大的正数足够大，能够覆盖所有负数，我们首先计算mx经过几次翻倍可以大于mi，然后让他翻倍，之后让所有的负数都加上这个mx它们都变成正数了，然后我们就判断一下这两种选择哪个更优即可&lt;/p&gt;</description></item><item><title>Lab1 DataLab</title><link>https://lunatide.tech/p/lab1-datalab/</link><pubDate>Sun, 28 Sep 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/lab1-datalab/</guid><description>&lt;img src="https://lunatide.tech/p/lab1-datalab/csapp.jpg" alt="Featured image of post Lab1 DataLab" /&gt;</description></item><item><title>lecture03 Bits,Bytes and Integer cout</title><link>https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/</link><pubDate>Fri, 26 Sep 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/</guid><description>&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/csappp.jpg" alt="Featured image of post lecture03 Bits,Bytes and Integer cout" /&gt;&lt;h2 id="加法"&gt;加法
&lt;/h2&gt;&lt;h3 id="无符号加法"&gt;无符号加法
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/addition.jpg"
width="1902"
height="1160"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/addition_hu_716bbff97dd22ccf.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/addition_hu_e5b30f30f868aa0e.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
&gt;&lt;/p&gt;
&lt;p&gt;无符号的加法很简单，和二进制加法一样，只不过要把overflow的删除，并且把结果取模即可&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/visualizing.jpg"
width="1072"
height="1038"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/visualizing_hu_f2f3910ed996a27e.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/visualizing_hu_c860ff4384a3d7c5.jpg 1024w"
loading="lazy"
alt="可视化整数加法图"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8A%A0%E6%B3%95%E5%9B%BE.jpg"
width="1080"
height="1060"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8A%A0%E6%B3%95%E5%9B%BE_hu_8494c559604648a0.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8A%A0%E6%B3%95%E5%9B%BE_hu_da4b3da714285c.jpg 1024w"
loading="lazy"
alt="可视化无符号加法图"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="244px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测无符号数中加法的溢出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 $s = U +_w^u V$ 为无符号整数 $U$ 和 $V$ 的和，那么当且仅当 $s &amp;lt; U$（或等价的 $s &amp;lt; V$）时产生溢出，这是因为：&lt;/p&gt;
$$
\begin{aligned}
s &amp;= U + V - 2^w &lt; U \\
s &amp;= U + V - 2^w &lt; V
\end{aligned}
$$&lt;h2 id="补码加法"&gt;补码加法
&lt;/h2&gt;&lt;p&gt;![](截屏2025-09-28 15.57.52.jpg)&lt;/p&gt;
&lt;p&gt;对满足 $-2^{w-1} \leq x$，$y \leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：&lt;/p&gt;
$$
x +_w^t y =
\begin{cases}
x + y - 2^w, &amp; 2^{w-1} \leq x + y \quad \text{正溢出} \\
x + y, &amp; -2^{w-1} \leq x + y &lt; 2^{w-1} \quad \text{正常} \\
x + y + 2^w, &amp; x + y &lt; -2^{w-1} \quad \text{负溢出}
\end{cases}
$$&lt;p&gt;
两个数的$w$位补码之和与无符号之和有完全相同的位级表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用左移做乘法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数机器中左移比乘法快
&lt;ul&gt;
&lt;li&gt;编译器会自动生成这样的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法的证明：&lt;/p&gt;
&lt;p&gt;假设 $x$ 的 $w$ 位二进制表示为 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$，那么 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}, 0, \cdots, 0\right]$ 给出了 $x2^k$ 的 $w+k$ 位二进制表示：&lt;/p&gt;
$$
\begin{aligned}
B2U_{w+k}\left(\left[x_{w-1}, x_{w-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) &amp;= \sum_{i=0}^{w-1} x_{i} 2^{i+k} \\
&amp;= \left[\sum_{i=0}^{w-1} x_{i} 2^{i}\right] \cdot 2^{k} \\
&amp;= x 2^{k}
\end{aligned}
$$&lt;p&gt;对于固定长度的表示，高 $k$ 位被丢弃，左移 $k$ 位的二进制表示为
&lt;/p&gt;
$$
\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]
$$&lt;p&gt;所以
&lt;/p&gt;
$$
\begin{aligned}
B2U_{w}\left(\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) &amp;= \sum_{i=0}^{w-k-1} x_{i} 2^{i+k} \\
&amp;= \left[\sum_{i=0}^{w-k-1} x_{i} 2^{i}\right] \cdot 2^{k} \\
&amp;= \left[\sum_{i=0}^{w-1} x_{i} 2^{i}\right] \cdot 2^{k} \mod 2^w \\
&amp;= x2^k \mod 2^w
\end{aligned}
$$&lt;p&gt;所以对于无符号整数
&lt;/p&gt;
$$
B2U_{w}\left(\left[x_{w-k-1}, x_{w-k-2}, \cdots, x_{0}, 0, \cdots, 0\right]\right) = \text{UMult}_w(x,2^k)
$$&lt;p&gt;对于有符号整数，利用
&lt;/p&gt;
$$
\text{TMult}_w(u,v) = U2T_w((u \cdot v) \mod 2^w)
$$&lt;p&gt;
可以得到相同的结果。&lt;/p&gt;
&lt;p&gt;一般情形&lt;/p&gt;
&lt;p&gt;现在考虑一般的情形，假设我们需要计算 $u \times K$，其中 $K$ 为常数，将 $K$ 表达为一组 $0$ 和 $1$ 交替的序列
&lt;/p&gt;
$$
[(0 \cdots 0)(1 \cdots 1)(0 \cdots 0) \cdots (1 \cdots 1)]
$$&lt;p&gt;考虑一组从位置 $n$ 到位置 $m$ 的连续 $1$，那么可以用如下方式计算这部分的对于乘积的影响：
&lt;/p&gt;
$$
\begin{aligned}
&amp;(x &lt;&lt; n) + (x &lt;&lt; (n-1)) + \cdots + (x &lt;&lt; m) \\
&amp;(x &lt;&lt; (n+1)) - (x &lt;&lt; m)
\end{aligned}
$$&lt;h2 id="移位操作和二进制乘除法的联系"&gt;移位操作和二进制乘除法的联系
&lt;/h2&gt;&lt;h3 id="使用移位操作代替除以-2-的幂无符号"&gt;使用移位操作代替除以 2 的幂（无符号）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$u &amp;raquo; k$ 给出 $\lfloor u / 2^{k} \rfloor$&lt;/li&gt;
&lt;li&gt;使用逻辑移位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/mul.jpg"
width="958"
height="268"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/mul_hu_8caa170d186c95.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/mul_hu_f99fbeb6eb694c06.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="857px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 $x$ 的 $w$ 位二进制表示为 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$，右移 $k$ 位的二进制表示为 $\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]$&lt;/p&gt;
$$
\begin{aligned}
B2U_w(\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]) &amp;= \sum_{i=0}^{w-k-1} x_{i+k} 2^{i} \\
B2U_{w}\left(\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]\right) &amp;= \sum_{i=0}^{w-1} x_{i} 2^{i} \\
&amp;= 2^k \sum_{i=0}^{w-k-1} x_{i+k} 2^{i} + \sum_{i=0}^{k-1} x_{i} 2^{i} \\
&amp;= 2^k B2U_w(\left[0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_{k}\right]) + \sum_{i=0}^{k-1} x_{i} 2^{i}
\end{aligned}
$$&lt;p&gt;所以
&lt;/p&gt;
$$
\lfloor x / 2^{k} \rfloor = x &gt;&gt; k
$$&lt;h3 id="使用移位操作代替除以-2-的幂有符号"&gt;使用移位操作代替除以 2 的幂（有符号）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$u &amp;raquo; k$ 给出 $\lfloor u / 2^{k} \rfloor$&lt;/li&gt;
&lt;li&gt;使用算数移位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 $u &amp;gt; 0$ 时上述方法和无符号情形一致，但是当 $u &amp;lt; 0$ 时则会产生有问题的结果，例如取 $u = -12340$：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/power.jpg"
width="946"
height="330"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/power_hu_d9c418a63cbd7841.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/power_hu_52ca23a0fce2f661.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
&gt;&lt;/p&gt;
&lt;p&gt;考虑 $k=4,8$ 时的结果，在 C 语言中实际结果为 $-771$ 和 $-48$，之所以和 C 语言中的结果不同，是因为上述算法朝着离 $0$ 更远的方向舍入，所以当 $u &amp;lt; 0$ 时要向上舍入，达到上述效果利用如下事实即可
&lt;/p&gt;
$$
\lceil x / y \rceil = \lfloor (x + y - 1) / y \rfloor
$$&lt;h2 id="unsigned"&gt;Unsigned
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须做一个明确的分配而不是暗示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易犯错误，例如下面的代码会出现无限循环&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;unsigend&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可能会变的很诡异&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define DELTA sizeof(int)&lt;/span&gt;&lt;span class="c1"&gt;//默认int的size是一个unsigned的size_t
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CNT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;DELTA&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;DELTA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//和上面的代码出现一样的问题
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正确的代码如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;什么时候用无符号整数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行模块化算术时使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多精度算术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用位表示集时使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑右移，无符号扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（最好不要用unsigned）&lt;/p&gt;
&lt;h2 id="内存中数字的一些底层表示"&gt;内存中数字的一些底层表示
&lt;/h2&gt;&lt;h3 id="word-size"&gt;Word Size
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件本身并不一定定义字长大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何给定的计算机都具有字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直到现在，大部份机器都采用32 bits(4 bytes)作为字长&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址限制为4 GB($2^{32}$bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;越来越多机器具有64位字长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器仍然支持多种数据格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字长的分数或整数倍&lt;/li&gt;
&lt;li&gt;但总是整数比特&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/2020050814.jpg"
width="416"
height="626"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/2020050814_hu_236969b163c8f936.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/2020050814_hu_5c8827325c770696.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="159px"
&gt;&lt;/p&gt;
&lt;h3 id="比特顺序"&gt;比特顺序
&lt;/h3&gt;&lt;p&gt;分为大端法和小端法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Example
&lt;ul&gt;
&lt;li&gt;变量x的value是0x01234567&lt;/li&gt;
&lt;li&gt;地址是0x100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/123.jpg"
width="2124"
height="584"
srcset="https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/123_hu_ca0ae2f247279d91.jpg 480w, https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/123_hu_d775fa03b9dc0007.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="363"
data-flex-basis="872px"
&gt;&lt;/p&gt;</description></item><item><title>lecture02 Bits,Bytes and Integer</title><link>https://lunatide.tech/p/lecture02-bitsbytes-and-integer/</link><pubDate>Wed, 24 Sep 2025 00:00:00 +0000</pubDate><guid>https://lunatide.tech/p/lecture02-bitsbytes-and-integer/</guid><description>&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/csapp.jpg" alt="Featured image of post lecture02 Bits,Bytes and Integer" /&gt;&lt;h2 id="bits"&gt;Bits
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么要用比特&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于用双稳态元件存储&lt;/li&gt;
&lt;li&gt;能在有噪声且不精确的电线上可靠传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/why-bits.jpg"
width="796"
height="249"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/why-bits_hu_db0e1589287f0e6f.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/why-bits_hu_544ef48d82bcf07.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
&gt;&lt;/p&gt;
&lt;p&gt;我们可以用二进制来表示浮点数。在一个二进制的小数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、…&lt;/li&gt;
&lt;li&gt;小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/encoding.jpg"
width="1970"
height="1236"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/encoding_hu_90858520df601cc9.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/encoding_hu_c9b2f1c44445d012.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个字节等于 8 比特&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="布尔代数"&gt;布尔代数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;比特之间的关系（操作）&lt;/li&gt;
&lt;li&gt;1 代表 true，0 代表 false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/boolenan.jpg"
width="1454"
height="716"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/boolenan_hu_47fd8da15e9935a9.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/boolenan_hu_b0cc73e741231d31.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="203"
data-flex-basis="487px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example：表示与操作集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示方式：
&lt;ul&gt;
&lt;li&gt;一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集&lt;/li&gt;
&lt;li&gt;如果 $a_j = 1，j ∈ A$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for example：{0, 3, 5, 6}
&lt;ul&gt;
&lt;li&gt;01101001&lt;/li&gt;
&lt;li&gt;76543210&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。&lt;/p&gt;
&lt;h3 id="对比逻辑运算符"&gt;对比逻辑运算符
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&amp;amp;、||、 !&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!0x41 → 0x00&lt;/li&gt;
&lt;li&gt;!0x99 → 0x01&lt;/li&gt;
&lt;li&gt;!!ox41 → 0x01&lt;/li&gt;
&lt;li&gt;0x69 &amp;amp;&amp;amp; 0x55 → 0x01&lt;/li&gt;
&lt;li&gt;p &amp;amp;&amp;amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="移位操作"&gt;移位操作
&lt;/h2&gt;&lt;h3 id="左移x--y"&gt;左移：x &amp;laquo; y
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;向左移动位次，多余的bits扔掉，添加相对应数目的0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="右移x--y"&gt;右移：x &amp;raquo; y
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑右移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和左移类似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数右移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若第一个数为1，把原本填充的0改为填充1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="整数编码"&gt;整数编码
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数&lt;/p&gt;
&lt;p&gt;$B2U(X) = \sum_{i = 0}^{w-1} x_i \cdot 2^i $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码(Two&amp;rsquo;s Complement)&lt;/p&gt;
&lt;p&gt;$B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数值范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W = 16&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value Type&lt;/th&gt;
&lt;th&gt;Formula / Binary Pattern&lt;/th&gt;
&lt;th&gt;Decimal&lt;/th&gt;
&lt;th&gt;Hex&lt;/th&gt;
&lt;th&gt;Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Unsigned Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UMin&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;00000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UMax&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;W&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;td&gt;0xFFFF&lt;/td&gt;
&lt;td&gt;11111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Two&amp;rsquo;s Complement Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TMin&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;W-1&lt;/sup&gt; / 100&amp;hellip;0&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;0x8000&lt;/td&gt;
&lt;td&gt;10000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TMax&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;W-1&lt;/sup&gt; - 1 / 011&amp;hellip;1&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;td&gt;0x7FFF&lt;/td&gt;
&lt;td&gt;01111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Other Values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;111&amp;hellip;1&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0xFFFF&lt;/td&gt;
&lt;td&gt;11111111 11111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;000&amp;hellip;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;00000000 00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此我们可以得到一个关系如下：&lt;/p&gt;
&lt;p&gt;​ $TMin = TMax + 1$&lt;/p&gt;
&lt;p&gt;​ $UMax = 2 \times TMax + 1$&lt;/p&gt;
&lt;h3 id="转换"&gt;转换
&lt;/h3&gt;&lt;p&gt;有符号整型和无符号整型和十进制的转换关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/123.jpg"
width="398"
height="604"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/123_hu_6784bc7cf29f5567.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/123_hu_e942a054b6ee95f.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="158px"
&gt;&lt;/p&gt;
&lt;p&gt;显然上述转换是可逆的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\text{U2B}(x)=\text{B2U}^{-1}(x)$&lt;/li&gt;
&lt;li&gt;$\text{T2B}(x)=\text{B2T}^{-1}(x)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用复合关系可以得到有符号整型以及无符号整型的转换关系：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/111.jpg"
width="980"
height="420"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/111_hu_86e9a1bb8947973c.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/111_hu_40f3ead3eb4aaf9b.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="560px"
&gt;&lt;/p&gt;
&lt;p&gt;对于$\text {TMin} \leqslant x \leqslant \text{TMax}$
&lt;/p&gt;
$$
T 2 U_w(x)=\left\{\begin{array}{ll}
x+2^{w}, &amp; x&lt;0 \\
x, &amp; x \geqslant 0
\end{array}\right.
$$&lt;p&gt;
对于$0 \leqslant x \leqslant \text{UMax}$
&lt;/p&gt;
$$
U 2 T_{w}(u)=\left\{\begin{array}{ll}
u, &amp; u \leqslant \text{TMax} \\
u-2^{w}, &amp; u&gt;\text{TMax}
\end{array}\right.
$$&lt;p&gt;下图为补码到无符号数的转换关系&lt;/p&gt;
&lt;p&gt;&lt;img src="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/222.jpg"
width="2078"
height="1344"
srcset="https://lunatide.tech/p/lecture02-bitsbytes-and-integer/222_hu_c8b3373b4ae2d50.jpg 480w, https://lunatide.tech/p/lecture02-bitsbytes-and-integer/222_hu_334248bba9997460.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="371px"
&gt;&lt;/p&gt;
&lt;p&gt;C语言中的转换如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//显示转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;tx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;uy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//隐式转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;tx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ux&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;uy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="表达式求值规则"&gt;表达式求值规则
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;若单个表达式中&lt;strong&gt;同时出现无符号数与有符号数&lt;/strong&gt;，则&lt;strong&gt;有符号值会被隐式转换为无符号数&lt;/strong&gt;（包括比较运算 &lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;举例：W = 32 位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常量定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TMIN = -2,147,483,648&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TMAX = 2,147,483,647&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;常量 1&lt;/th&gt;
&lt;th&gt;常量 2&lt;/th&gt;
&lt;th&gt;实际类型&lt;/th&gt;
&lt;th&gt;关系&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;假&lt;/td&gt;
&lt;td&gt;两者均为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt; 被转成 &lt;code&gt;4294967295U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2147483648&lt;/code&gt; 被转成 &lt;code&gt;2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;普通有符号比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(unsigned)-1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-2&lt;/code&gt; 被转成 &lt;code&gt;4294967294U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;前者 &amp;lt; 后者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2147483647&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(int)2147483648U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真&lt;/td&gt;
&lt;td&gt;后者溢出成 &lt;code&gt;-2147483648&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="小结有符号与无符号强制转换的基本规则"&gt;小结：有符号与无符号强制转换的基本规则
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;位模式保持不变&lt;/strong&gt;&lt;br&gt;
强制转换时，内存中的 0/1 序列原样复制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;仅重新解释&lt;/strong&gt;&lt;br&gt;
同一段位模式，按目标类型（有符号或无符号）重新解读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可能产生“意外”&lt;/strong&gt;&lt;br&gt;
数值可能突然加上或减去 2^W（W 为位数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表达式中的混合类型&lt;/strong&gt;&lt;br&gt;
只要表达式里&lt;strong&gt;同时出现&lt;/strong&gt;&lt;code&gt;signed int&lt;/code&gt;与&lt;code&gt;unsigned int&lt;/code&gt; ，&lt;strong&gt;编译器会把 &lt;code&gt;signed int&lt;/code&gt; 隐式转换成 &lt;code&gt;unsigned int&lt;/code&gt;&lt;/strong&gt;，再参与运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="扩展截断"&gt;扩展，截断
&lt;/h2&gt;&lt;h3 id="扩展"&gt;扩展
&lt;/h3&gt;&lt;p&gt;无符号扩展至需要在前面的bits补0,有符号扩展如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定w-bit的有符号整型x&lt;/li&gt;
&lt;li&gt;将其转换为w+k-bit的有符号整型，值不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;p&gt;将符号位复制k份&lt;/p&gt;
&lt;p&gt;$X&amp;rsquo; = X_{w-1},\dots,X_{w-1},X_{w-1},X_{w-2},\dots,X_0$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;补码的符号扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义宽度为 $w$ 的位向量 $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ 和宽度为 $w&amp;rsquo;$ 的位向量 $\vec{x}&amp;rsquo; = [x&amp;rsquo;&lt;em&gt;{w&amp;rsquo;-1}, x&amp;rsquo;&lt;/em&gt;{w&amp;rsquo;-2}, \dots, x&amp;rsquo;&lt;em&gt;0]$，其中 $w&amp;rsquo; &amp;gt; w$。则$B2T_w(\vec{x}) = B2T&lt;/em&gt;{w&amp;rsquo;}(\vec{x}&amp;rsquo;)$，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码数值的符号扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令$w&amp;rsquo; = w + k$，我们想要证明的是
&lt;/p&gt;
$$
B2T_{w+k} ([x_{w-1}, \cdots, x_{w-1}, x_{w-2}, \cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
$$&lt;p&gt;下面的证明是对$k$进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了：
&lt;/p&gt;
$$
B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
$$&lt;p&gt;展开左边的表达式，得到：
&lt;/p&gt;
$$
\begin{aligned}
B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \cdots, x_0]) &amp;= -x_{w-1}2^w + \sum_{i=0}^{w-1}x_i2^i \\
&amp;= -x_{w-1}2^w + x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= -x_{w-1}(2^w - 2^{w-1}) + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\
&amp;= B2T_w([x_{w-1}, x_{w-2}, \cdots, x_0])
\end{aligned}
$$&lt;p&gt;我们使用的关键属性是$2^w - 2^{w-1} = 2^{w-1}$。因此，加上一个权值为$-2^w$的位，和将一个权值为 $-2^{w-1}$的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。&lt;/p&gt;
&lt;h3 id="截断"&gt;截断
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;无符号截断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原始 $w$ 位：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2U}_w(X)=\sum_{i=0}^{w-1} x_i\cdot2^i
$$&lt;p&gt;截断为 $k$ 位后：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2U}_k(X)=\sum_{i=0}^{k-1} x_i\cdot2^i = \mathrm{B2U}_w(X)\bmod 2^k
$$&lt;p&gt;&lt;strong&gt;推导&lt;/strong&gt;
&lt;/p&gt;
$$
\begin{aligned}
B2U_w([x_{w-1}, x_{w-2}, \cdots, x_0]) \mod 2^k &amp;= \left[ \sum_{i=0}^{w-1} x_i 2^i \right] \mod 2^k \\
&amp;= \left[ \sum_{i=0}^{k-1} x_i 2^i \right] \mod 2^k \\
&amp;= \sum_{i=0}^{k-1} x_i 2^i \\
&amp;= B2U_k([x_{k-1}, x_{k-2}, \cdots, x_0])
\end{aligned}
$$&lt;p&gt;&lt;strong&gt;有符号截断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原始 $w$ 位：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2T}_w(X)=-x_{w-1}\cdot2^{w-1}+\sum_{i=0}^{w-2} x_i\cdot2^i
$$&lt;p&gt;
截断为 $k$ 位后：&lt;br&gt;
&lt;/p&gt;
$$
\mathrm{B2T}_k(X)=-x_{k-1}\cdot2^{k-1}+\sum_{i=0}^{k-2} x_i\cdot2^i = \mathrm{U2T}_k\!\bigl(\mathrm{B2U}_w(X)\bmod 2^k\bigr)
$$</description></item></channel></rss>