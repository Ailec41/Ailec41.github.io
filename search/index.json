[{"content":"从感知机到神经网络 感知机回顾 用图来表示神经网络，类比感知机，我们把左边的一列称为输入层，最右边的称之为输出层，中间的称为中间层(也称为隐藏层，因为神经元肉眼看不见)，我们知道当感知机接受$x_1,x_2$两个输入信号，输出$y$时，可以用如下的数学式来表示 $$ y = \\begin{cases} 0, \u0026 b + w_1 x_1 + w_2 x_2 \\le 0 \\\\ 1, \u0026 b + w_1 x_1 + w_2 x_2 \u003e 0 \\end{cases} \\tag{1} $$ $b$是偏置，用于控制神经元被激活的容易程度，而$w_1,w_2$是表示各个信号的权重的参数，用于控制各个信号的重要性\n我们现在可以通过调用一个函数来替代(1)中分case讨论的情况来简化(1)，改写成如下形式 $$ y = h(b + w_1x_1+ w_2x_2)\\tag{2} $$$$ h(x) = \\begin{cases} 0, \u0026 x \\le 0 \\\\ 1, \u0026 x \u003e 0 \\end{cases}\\tag{3} $$激活函数引入 刚才的h(x)把输入信号的总和转换成了输出信号，h(x)就被称为激活函数(activation function)\n现在进一步改写式(2)，写成如下形式 $$ a = b + w_1x_1 + w_2x_2\\tag{4} $$$$ y = h(a)\\tag{5} $$首先，式(4)计算加权输入信号的和偏置的总和，然后用(5)的h函数转换为输出\n激活函数 sigmoid函数 神经网络中经常使用的一个激活函数就是sigmoid函数 $$ h(x)=\\frac{1}{1+e^{-x}} \\quad (\\text{sigmoid function})\\tag{6} $$ 实际上，感知机和神经网络的主要区别就在于激活函数，其他方面基本都是一样的\n阶跃函数的实现 阶跃函数如(3)所示，当输入超过0时，输出1，否则输出0，可以用如下代码简单实现\n1 2 3 4 5 def step_function(x): if x \u0026gt; 0: return 1 else: return 0 这个代码中参数x只能接受实数。例如不允许step_function(np.array([1.0,2.0]))，所以我们把它修改为支持NumPy数组的实现\n1 2 3 def step_function(x): y = x \u0026gt; 0 return y.astype(np.int) 阶跃函数的图形 接下来我们就用图来表示上面定义的阶跃函数\n1 2 3 4 5 6 7 8 9 10 11 import numpy as np import matplotlib.pylab as plt def step_function(x): return np.array(x \u0026gt; 0,dtype=np.int) x = np.arange(-5.0,5.0,0.1) y = step_function(x) plt.plot(x,y) plt.ylim(-0.1,1.1) #y轴范围 plt.show() sigmoid函数的实现 1 2 def sigmoid(x): return 1 / (1 + np.exp(-x)) 之所以sigmoid函数的实现支持NumPy数组，就是因为NumPy的广播功能，如果在标量和NumPy数组之间进行运算，标量会和NumPy数组的各个元素进行运算，np.exp(-x)会生成NumPy数组，所以1/(1 + np.exp(-x))的运算将会在NumPy数组的各个元素间进行\nsigmoid函数和阶跃函数的比较 观察可以发现，首先区别就是平滑性，sigmoid函数是一条平滑的曲线，输出随着输入发生连续性的变化。而阶跃函数以0为界，输出发生急剧性的变化。因此我们可以知道，感知机的神经元之间流动的是0或1的二元信号，神经网络中流动的是连续的实数值信号。\n然后说一下阶跃函数和sigmoid函数的共同性质，两者的结构均是“输入小时输出接近0；输入大时，输出靠近1”，以及不管输入是什么值，输出信号的值都在0和1中间\n非线性函数 阶跃函数和sigmoid函数都是非线性函数\n神经网络的激活函数必须使用非线性函数，因为如果使用线性函数，加深神经网络的层数就没有意义了（应该很好理解，很多线型函数复合仍然是线性的，就不具体说了）\nReLU函数 最近比较常见的是ReLU函数\nReLU函数在输入大于0时，直接输出该值；在输入小于等于0的时候，输出0\nReLU函数可以表示为以下数学式 $$ h(x) =\\begin{cases} x, \u0026 x \u003e 0 \\\\ 0, \u0026 x \\le 0 \\end{cases} \\tag{7} $$ ReLU函数的实现也非常简单\n1 2 def relu(x): return np.maximum(0,x) 多维数组的运算 多维数组 首先假定有一个一维数组A = np.array[1,2,3,4]，数组的维数可以通过np.ndim得到。数组的形状可以通过实例变量shape获得，A由四个元素构成，是一维的，所以A.shape就是（4，），这个结果是个元组，这个一维数组为了保证和多维一样的格式，所以仍然被写成元组\n矩阵乘法 不再赘述\n神经网络的内积 ","date":"2025-11-10T00:00:00Z","image":"https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1/pic3_hu_2daba19cf5c34236.jpg","permalink":"https://lunatide.tech/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1/","title":"深度学习笔记-神经网络(1)"},{"content":"四个Projects都做完了，但是还在刷Leaderboa，有空就update博客内容\n","date":"2025-10-25T00:00:00Z","image":"https://lunatide.tech/p/cmu15445-project01/good_hu_3561d7aa0c4c4079.jpg","permalink":"https://lunatide.tech/p/cmu15445-project01/","title":"CMU15445-Project01"},{"content":"POJ-2318\n","date":"2025-10-16T00:00:00Z","image":"https://lunatide.tech/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A1%B9/codeforce_%E5%89%AF%E6%9C%AC_hu_f47c20acf40349f0.jpg","permalink":"https://lunatide.tech/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A1%B9/","title":"计算几何专项"},{"content":"日常的训练，回顾一下做的几道题，实现不发\nICPC Hangzhou Reginal F Fuzzy Ranking 不太会做，看了一下题解，下面是看完题解后的思路\n直接为任意“前→后”对连边会太多，在同一排列中，只连相邻元素 $a_j\\to a_{j+1}$ 即可：因为一条从前往后的有向路径已经能覆盖该排列中任意“前→后”的可达关系。对所有 $k$ 个排列加边\n对图做一次 Tarjan/Kosaraju缩点，得到每个学校所属的 SCC 编号bel[x]，以及按拓扑序逆序排列的分量列表 scc。把每个榜单按 bel重新映射成“分量编号序列”。\n在某个榜单中，原先相邻的两点之间有边，缩点后相同分量的编号在该榜单上必然连成一段。因此每个榜单都可以被切成若干段，每段恰好由同一个 SCC 的元素组成。这个性质让我们可以把任意区间 $[l,r]$ 拆解为：左端一个不完整段 + 中间若干完整段 + 右端一个不完整段。\n对每个榜单i:\nSegment：对位置轴进行分段。令 Segment= (L, R) 表示pos所在的那段在该榜单上的左右端点下标。线性扫，遇到一段相同编号的区间 $[L,R]$ 就把这对端点填给其中的每个位置。\ndp 前缀：统计从开头到位置 $j$ 为止、同段内能形成的“模糊对”数量。若 $j$ 落在段 $[L,R]$，新增的成对数等于该段里被纳入的元素个数减一，即 $j-L$。因此定义 $$ dp[id][j] = dp[id][j-1] + (j-L). $$ 这样任意区间 $[x,y]$ 的“在同一段内形成的对数”就能通过 $dp$ 差分 $dp[id][y]-dp[id][x]$ 得到。\n总计复杂度$O(nk)$\nCF1841E Fill the Matrix 题目说有一个$n * n$的正方形矩阵，在第$i$列，前$a_i$个格子都是黑色，剩下的格子是白色，在矩阵放入1到m到整数，每个格子最多放一个且黑色格子不能放，定义美丽值为数字 $j$ 和 $j+1$ 位于同一行，且 $j+1$ 位于 $j$ 的右边相邻的格子，求放置m个整数后最大美丽值\n我们一定先选一个最长的白色格子全填进去，直到填满或者数不够。因为如果不继续填等于说最后填的那个数旁边的格子就浪费了，所以关键就在于要把所有行的白色连续横段都计算出来，按长度分组，记为cnt[n]，代表长度n的横段有几个，直接暴力扫迷线维护复杂度是$O(n^2)$的，直接炸了，所以我们用线段树来维护最大值和位置然后再分治来统计cnt数组，相当于构建一颗笛卡尔树，每次把区间按最大值分为左右两部分，统计每层能产生的白格段，最后用贪心计算答案就可以了，这样最后复杂度就控制在$O(nlogn)$\nCF2056D Unique Median 2200 给了一个整数数组b，当排序后满足$b⌊\\frac{m+1}{2}⌋=b⌈\\frac{m+1}{2}⌉$时我们说数组是好的，题目说给一个长度为n的数组a，计算好子数组数量\n首先观察好数组定义，我们可以很容易发现奇数长度的数组一定是好数组，所以我们只要看偶数长度的数组就可以了，很困难，想了一段时间，一开始的想法是如果我们要让偶数的数组是好的，那么当且仅当存在某个数$v$，使得在选取的子数组中$v \\ge m/2$，也就是说至少一半都是同一个数，但是肯定会有重复用容斥修正，减掉重复的就可以，实现很麻烦，写了很久，而且还发现是错误的，对于[1,1,2,3]按照这个思路明显错的，而且发现正着处理非常麻烦困难，于是决定反向试试，从所有子数组中减掉\u0026quot;坏的\u0026quot;，再修正\n很快就发现了一些东西，对于一个偶数的数组，只要让排序后第k个数小于k+1个数一定是坏的，再具体点，我们选定两个相邻的数x，y，我们只要让左中位数小于等于x，右中位数大于等于y就可以了，然后用前缀和+map即可，并且小于等于x的数的数量和大于等于y的数字数量必须要一样多，那么我们可以把数组按照值分为3类，一种小于等于x我们记为-1，大于等于y记为+1，介于x和y之间的我们直接清空，因为出现就相当于直接破坏了我们的数组\n最后就是用容斥进行修正，只要x和y相差超过2就记为重复的减掉就可以了\nCF1854A2 Dual (Hard Version) 一道思维题，给了一个数组，可以对于$i,j$的元素进行操作，使得$a_i := a_i + a_j$\n要求在31次操作内让数组不递减\n首先当所有元素都大于等于0或者全部都小于等于0的时候很显然，我们只需要把右边的数依次加上左边的数肯定是对的（小于等于0同理反过来就行）\n所以关键是要看数组里有正有负，我们设最大的正数是mx，绝对值最大的负数是mi，正数数量是cp，负数数量是cm，那么我们有两种选择，一种是都统一成非负，一种是统一成非正，只要符号统一我们就方便了，拿统一非负举例（非正同理），我们其实就是要让最大的正数足够大，能够覆盖所有负数，我们首先计算mx经过几次翻倍可以大于mi，然后让他翻倍，之后让所有的负数都加上这个mx它们都变成正数了，然后我们就判断一下这两种选择哪个更优即可\n","date":"2025-10-09T00:00:00Z","image":"https://lunatide.tech/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/codeforce_%E5%89%AF%E6%9C%AC_hu_f47c20acf40349f0.jpg","permalink":"https://lunatide.tech/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/","title":"ICPC日常训练01"},{"content":"","date":"2025-09-28T00:00:00Z","image":"https://lunatide.tech/p/lab1-datalab/csapp_hu_113ffe23e1ef718.jpg","permalink":"https://lunatide.tech/p/lab1-datalab/","title":"Lab1 DataLab"},{"content":"加法 无符号加法 无符号的加法很简单，和二进制加法一样，只不过要把overflow的删除，并且把结果取模即可\n检测无符号数中加法的溢出\n令 $s = U +_w^u V$ 为无符号整数 $U$ 和 $V$ 的和，那么当且仅当 $s \u0026lt; U$（或等价的 $s \u0026lt; V$）时产生溢出，这是因为：\n$$ \\begin{aligned} s \u0026= U + V - 2^w \u003c U \\\\ s \u0026= U + V - 2^w \u003c V \\end{aligned} $$补码加法 ![](截屏2025-09-28 15.57.52.jpg)\n对满足 $-2^{w-1} \\leq x$，$y \\leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：\n$$ x +_w^t y = \\begin{cases} x + y - 2^w, \u0026 2^{w-1} \\leq x + y \\quad \\text{正溢出} \\\\ x + y, \u0026 -2^{w-1} \\leq x + y \u003c 2^{w-1} \\quad \\text{正常} \\\\ x + y + 2^w, \u0026 x + y \u003c -2^{w-1} \\quad \\text{负溢出} \\end{cases} $$ 两个数的$w$位补码之和与无符号之和有完全相同的位级表示\n利用左移做乘法\n大多数机器中左移比乘法快 编译器会自动生成这样的代码 方法的证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，那么 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]$ 给出了 $x2^k$ 的 $w+k$ 位二进制表示：\n$$ \\begin{aligned} B2U_{w+k}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= x 2^{k} \\end{aligned} $$对于固定长度的表示，高 $k$ 位被丢弃，左移 $k$ 位的二进制表示为 $$ \\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right] $$所以 $$ \\begin{aligned} B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-k-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-k-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\mod 2^w \\\\ \u0026= x2^k \\mod 2^w \\end{aligned} $$所以对于无符号整数 $$ B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) = \\text{UMult}_w(x,2^k) $$对于有符号整数，利用 $$ \\text{TMult}_w(u,v) = U2T_w((u \\cdot v) \\mod 2^w) $$ 可以得到相同的结果。\n一般情形\n现在考虑一般的情形，假设我们需要计算 $u \\times K$，其中 $K$ 为常数，将 $K$ 表达为一组 $0$ 和 $1$ 交替的序列 $$ [(0 \\cdots 0)(1 \\cdots 1)(0 \\cdots 0) \\cdots (1 \\cdots 1)] $$考虑一组从位置 $n$ 到位置 $m$ 的连续 $1$，那么可以用如下方式计算这部分的对于乘积的影响： $$ \\begin{aligned} \u0026(x \u003c\u003c n) + (x \u003c\u003c (n-1)) + \\cdots + (x \u003c\u003c m) \\\\ \u0026(x \u003c\u003c (n+1)) - (x \u003c\u003c m) \\end{aligned} $$移位操作和二进制乘除法的联系 使用移位操作代替除以 2 的幂（无符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用逻辑移位 证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，右移 $k$ 位的二进制表示为 $\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]$\n$$ \\begin{aligned} B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) \u0026= \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} \\\\ B2U_{w}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i} \\\\ \u0026= 2^k \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\\\ \u0026= 2^k B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\end{aligned} $$所以 $$ \\lfloor x / 2^{k} \\rfloor = x \u003e\u003e k $$使用移位操作代替除以 2 的幂（有符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用算数移位 当 $u \u0026gt; 0$ 时上述方法和无符号情形一致，但是当 $u \u0026lt; 0$ 时则会产生有问题的结果，例如取 $u = -12340$：\n考虑 $k=4,8$ 时的结果，在 C 语言中实际结果为 $-771$ 和 $-48$，之所以和 C 语言中的结果不同，是因为上述算法朝着离 $0$ 更远的方向舍入，所以当 $u \u0026lt; 0$ 时要向上舍入，达到上述效果利用如下事实即可 $$ \\lceil x / y \\rceil = \\lfloor (x + y - 1) / y \\rfloor $$Unsigned 必须做一个明确的分配而不是暗示\n容易犯错误，例如下面的代码会出现无限循环\n1 2 3 unsigend i; for(i = cnt - 2;i \u0026gt;= 2;i --) a[i] += a[i + 1]; 可能会变的很诡异\n1 2 3 #define DELTA sizeof(int)//默认int的size是一个unsigned的size_t int i; for(i = CNT;i - DELTA \u0026gt;= 0;i -=DELTA)//和上面的代码出现一样的问题 正确的代码如下\n1 2 3 size_t i; for (i = cnt-2; i \u0026lt; cnt; i--) a[i] += a[i+1]; 什么时候用无符号整数\n执行模块化算术时使用\n多精度算术 在使用位表示集时使用\n逻辑右移，无符号扩展 （最好不要用unsigned）\n内存中数字的一些底层表示 Word Size 硬件本身并不一定定义字长大小\n任何给定的计算机都具有字长\n直到现在，大部份机器都采用32 bits(4 bytes)作为字长\n地址限制为4 GB($2^{32}$bytes) 越来越多机器具有64位字长\n机器仍然支持多种数据格式\n字长的分数或整数倍 但总是整数比特 比特顺序 分为大端法和小端法\nExample 变量x的value是0x01234567 地址是0x100 ","date":"2025-09-26T00:00:00Z","image":"https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/csappp_hu_d6260cc969558569.jpg","permalink":"https://lunatide.tech/p/lecture03-bitsbytes-and-integer-cout/","title":"lecture03 Bits,Bytes and Integer cout"},{"content":"Bits 为什么要用比特\n易于用双稳态元件存储 能在有噪声且不精确的电线上可靠传输 我们可以用二进制来表示浮点数。在一个二进制的小数中：\n小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、… 小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、… 因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。\n字节\n一个字节等于 8 比特 布尔代数 比特之间的关系（操作） 1 代表 true，0 代表 false Example：表示与操作集合\n表示方式： 一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集 如果 $a_j = 1，j ∈ A$ for example：{0, 3, 5, 6} 01101001 76543210 对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。\n对比逻辑运算符 \u0026amp;\u0026amp;、||、 ! Example：\n!0x41 → 0x00 !0x99 → 0x01 !!ox41 → 0x01 0x69 \u0026amp;\u0026amp; 0x55 → 0x01 p \u0026amp;\u0026amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用） 移位操作 左移：x \u0026laquo; y 向左移动位次，多余的bits扔掉，添加相对应数目的0 右移：x \u0026raquo; y 逻辑右移\n和左移类似 算数右移\n若第一个数为1，把原本填充的0改为填充1 整数编码 无符号数\n$B2U(X) = \\sum_{i = 0}^{w-1} x_i \\cdot 2^i $\n补码(Two\u0026rsquo;s Complement)\n$B2T(X) = -x_{w-1} \\cdot 2^{w-1} + \\sum_{i=0}^{w-2} x_i \\cdot 2^i$\n数值范围\nW = 16\nValue Type Formula / Binary Pattern Decimal Hex Binary Unsigned Values UMin 0 0 0x0000 00000000 00000000 UMax 2W - 1 65535 0xFFFF 11111111 11111111 Two\u0026rsquo;s Complement Values TMin -2W-1 / 100\u0026hellip;0 -32768 0x8000 10000000 00000000 TMax 2W-1 - 1 / 011\u0026hellip;1 32767 0x7FFF 01111111 11111111 Other Values -1 111\u0026hellip;1 -1 0xFFFF 11111111 11111111 0 000\u0026hellip;0 0 0x0000 00000000 00000000 因此我们可以得到一个关系如下：\n​\t$TMin = TMax + 1$\n​\t$UMax = 2 \\times TMax + 1$\n转换 有符号整型和无符号整型和十进制的转换关系如下：\n显然上述转换是可逆的：\n$\\text{U2B}(x)=\\text{B2U}^{-1}(x)$ $\\text{T2B}(x)=\\text{B2T}^{-1}(x)$ 利用复合关系可以得到有符号整型以及无符号整型的转换关系：\n对于$\\text {TMin} \\leqslant x \\leqslant \\text{TMax}$ $$ T 2 U_w(x)=\\left\\{\\begin{array}{ll} x+2^{w}, \u0026 x\u003c0 \\\\ x, \u0026 x \\geqslant 0 \\end{array}\\right. $$ 对于$0 \\leqslant x \\leqslant \\text{UMax}$ $$ U 2 T_{w}(u)=\\left\\{\\begin{array}{ll} u, \u0026 u \\leqslant \\text{TMax} \\\\ u-2^{w}, \u0026 u\u003e\\text{TMax} \\end{array}\\right. $$下图为补码到无符号数的转换关系\nC语言中的转换如下：\n1 2 3 4 5 6 7 8 9 int tx, ty; unsigned ux, uy; //显示转换 tx = (int) ux; uy = (unsigned) ty; //隐式转换 tx = ux; uy = ty 表达式求值规则 若单个表达式中同时出现无符号数与有符号数，则有符号值会被隐式转换为无符号数（包括比较运算 \u0026lt;、\u0026gt;、==、\u0026lt;=、\u0026gt;=）。\n举例：W = 32 位\n常量定义\nTMIN = -2,147,483,648 TMAX = 2,147,483,647 常量 1 常量 2 实际类型 关系 结果 说明 0 0U 无符号 \u0026lt; 假 两者均为 0 -1 0 有符号 \u0026lt; 真 普通有符号比较 -1 0U 无符号 \u0026gt; 真 -1 被转成 4294967295U 2147483647 -2147483648 有符号 \u0026gt; 真 普通有符号比较 2147483647U -2147483648 无符号 \u0026lt; 真 -2147483648 被转成 2147483648U -1 -2 有符号 \u0026gt; 真 普通有符号比较 (unsigned)-1 -2 无符号 \u0026gt; 真 -2 被转成 4294967294U 2147483647 2147483648U 无符号 \u0026lt; 真 前者 \u0026lt; 后者 2147483647 (int)2147483648U 有符号 \u0026gt; 真 后者溢出成 -2147483648 小结：有符号与无符号强制转换的基本规则 位模式保持不变\n强制转换时，内存中的 0/1 序列原样复制。\n仅重新解释\n同一段位模式，按目标类型（有符号或无符号）重新解读。\n可能产生“意外”\n数值可能突然加上或减去 2^W（W 为位数）。\n表达式中的混合类型\n只要表达式里同时出现signed int与unsigned int ，编译器会把 signed int 隐式转换成 unsigned int，再参与运算。\n扩展，截断 扩展 无符号扩展至需要在前面的bits补0,有符号扩展如下\n任务：\n给定w-bit的有符号整型x 将其转换为w+k-bit的有符号整型，值不变 规则：\n将符号位复制k份\n$X\u0026rsquo; = X_{w-1},\\dots,X_{w-1},X_{w-1},X_{w-2},\\dots,X_0$\n补码的符号扩展\n定义宽度为 $w$ 的位向量 $\\vec{x} = [x_{w-1}, x_{w-2}, \\dots, x_0]$ 和宽度为 $w\u0026rsquo;$ 的位向量 $\\vec{x}\u0026rsquo; = [x\u0026rsquo;{w\u0026rsquo;-1}, x\u0026rsquo;{w\u0026rsquo;-2}, \\dots, x\u0026rsquo;0]$，其中 $w\u0026rsquo; \u0026gt; w$。则$B2T_w(\\vec{x}) = B2T{w\u0026rsquo;}(\\vec{x}\u0026rsquo;)$，\n补码数值的符号扩展\n令$w\u0026rsquo; = w + k$，我们想要证明的是 $$ B2T_{w+k} ([x_{w-1}, \\cdots, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$下面的证明是对$k$进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了： $$ B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$展开左边的表达式，得到： $$ \\begin{aligned} B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) \u0026= -x_{w-1}2^w + \\sum_{i=0}^{w-1}x_i2^i \\\\ \u0026= -x_{w-1}2^w + x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}(2^w - 2^{w-1}) + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\end{aligned} $$我们使用的关键属性是$2^w - 2^{w-1} = 2^{w-1}$。因此，加上一个权值为$-2^w$的位，和将一个权值为 $-2^{w-1}$的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。\n截断 无符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2U}_w(X)=\\sum_{i=0}^{w-1} x_i\\cdot2^i $$截断为 $k$ 位后：\n$$ \\mathrm{B2U}_k(X)=\\sum_{i=0}^{k-1} x_i\\cdot2^i = \\mathrm{B2U}_w(X)\\bmod 2^k $$推导 $$ \\begin{aligned} B2U_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\mod 2^k \u0026= \\left[ \\sum_{i=0}^{w-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\left[ \\sum_{i=0}^{k-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\sum_{i=0}^{k-1} x_i 2^i \\\\ \u0026= B2U_k([x_{k-1}, x_{k-2}, \\cdots, x_0]) \\end{aligned} $$有符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2T}_w(X)=-x_{w-1}\\cdot2^{w-1}+\\sum_{i=0}^{w-2} x_i\\cdot2^i $$ 截断为 $k$ 位后：\n$$ \\mathrm{B2T}_k(X)=-x_{k-1}\\cdot2^{k-1}+\\sum_{i=0}^{k-2} x_i\\cdot2^i = \\mathrm{U2T}_k\\!\\bigl(\\mathrm{B2U}_w(X)\\bmod 2^k\\bigr) $$","date":"2025-09-24T00:00:00Z","image":"https://lunatide.tech/p/lecture02-bitsbytes-and-integer/csapp_hu_d6260cc969558569.jpg","permalink":"https://lunatide.tech/p/lecture02-bitsbytes-and-integer/","title":"lecture02 Bits,Bytes and Integer"}]