[{"content":"","date":"2025-09-28T00:00:00Z","image":"https://ailec41.github.io/p/lab1-datalab/csapp_hu_113ffe23e1ef718.jpg","permalink":"https://ailec41.github.io/p/lab1-datalab/","title":"Lab1 DataLab"},{"content":"整型 加法 无符号加法 无符号的加法很简单，和二进制加法一样，只不过要把overflow的删除，并且把结果取模即可\n![可视化无符号加法图](截屏2025-09-28 15.51.13.jpg)\n检测无符号数中加法的溢出\n令 $s = U +_w^u V$ 为无符号整数 $U$ 和 $V$ 的和，那么当且仅当 $s \u0026lt; U$（或等价的 $s \u0026lt; V$）时产生溢出，这是因为：\n$$ \\begin{aligned} s \u0026= U + V - 2^w \u003c U \\\\ s \u0026= U + V - 2^w \u003c V \\end{aligned} $$补码加法 ![](截屏2025-09-28 15.57.52.jpg)\n对满足 $-2^{w-1} \\leq x$，$y \\leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：\n$$ x +_w^t y = \\begin{cases} x + y - 2^w, \u0026 2^{w-1} \\leq x + y \\quad \\text{正溢出} \\\\ x + y, \u0026 -2^{w-1} \\leq x + y \u003c 2^{w-1} \\quad \\text{正常} \\\\ x + y + 2^w, \u0026 x + y \u003c -2^{w-1} \\quad \\text{负溢出} \\end{cases} $$ 两个数的$w$位补码之和与无符号之和有完全相同的位级表示\n利用左移做乘法\n大多数机器中左移比乘法快 编译器会自动生成这样的代码 方法的证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，那么 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]$ 给出了 $x2^k$ 的 $w+k$ 位二进制表示：\n$$ \\begin{aligned} B2U_{w+k}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= x 2^{k} \\end{aligned} $$对于固定长度的表示，高 $k$ 位被丢弃，左移 $k$ 位的二进制表示为 $$ \\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right] $$所以 $$ \\begin{aligned} B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-k-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-k-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\mod 2^w \\\\ \u0026= x2^k \\mod 2^w \\end{aligned} $$所以对于无符号整数 $$ B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) = \\text{UMult}_w(x,2^k) $$对于有符号整数，利用 $$ \\text{TMult}_w(u,v) = U2T_w((u \\cdot v) \\mod 2^w) $$ 可以得到相同的结果。\n一般情形\n现在考虑一般的情形，假设我们需要计算 $u \\times K$，其中 $K$ 为常数，将 $K$ 表达为一组 $0$ 和 $1$ 交替的序列 $$ [(0 \\cdots 0)(1 \\cdots 1)(0 \\cdots 0) \\cdots (1 \\cdots 1)] $$考虑一组从位置 $n$ 到位置 $m$ 的连续 $1$，那么可以用如下方式计算这部分的对于乘积的影响： $$ \\begin{aligned} \u0026(x \u003c\u003c n) + (x \u003c\u003c (n-1)) + \\cdots + (x \u003c\u003c m) \\\\ \u0026(x \u003c\u003c (n+1)) - (x \u003c\u003c m) \\end{aligned} $$移位操作和二进制乘除法的联系 使用移位操作代替除以 2 的幂（无符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用逻辑移位 证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，右移 $k$ 位的二进制表示为 $\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]$\n$$ \\begin{aligned} B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) \u0026= \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} \\\\ B2U_{w}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i} \\\\ \u0026= 2^k \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\\\ \u0026= 2^k B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\end{aligned} $$所以 $$ \\lfloor x / 2^{k} \\rfloor = x \u003e\u003e k $$使用移位操作代替除以 2 的幂（有符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用算数移位 当 $u \u0026gt; 0$ 时上述方法和无符号情形一致，但是当 $u \u0026lt; 0$ 时则会产生有问题的结果，例如取 $u = -12340$：\n考虑 $k=4,8$ 时的结果，在 C 语言中实际结果为 $-771$ 和 $-48$，之所以和 C 语言中的结果不同，是因为上述算法朝着离 $0$ 更远的方向舍入，所以当 $u \u0026lt; 0$ 时要向上舍入，达到上述效果利用如下事实即可 $$ \\lceil x / y \\rceil = \\lfloor (x + y - 1) / y \\rfloor $$","date":"2025-09-26T00:00:00Z","image":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/csappp_hu_d6260cc969558569.jpg","permalink":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/","title":"lecture03 Bits,Bytes and Integer cout"},{"content":"G. Buratsuta 3 time limit per test: 4.5 seconds\nmemory limit per test: 256 megabytes\nIn the ruthless world of Blue Lock, Buratsuta 3 is a trio selected to overthrow the reigning champions and lead the Japan U-20 team to glory. Sae Itoshi has already secured his place as the first participant; the remaining two spots will be contested in the tough Side-B selection.\nTo test the strategic abilities of the candidates, Buratsuta has posed the following challenge:\nYou are given an array of $n$ integers called performance records and $q$ queries.\nEach query specifies a subarray $[l, r]$. In this subarray, find all record values that occur strictly more than: $$ \\left\\lfloor \\frac{r - l + 1}{3} \\right\\rfloor $$ times.\nInput\nEach test consists of several test cases.\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$) — the number of records and the number of queries. The second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — the performance records. Each of the following $q$ lines contains two integers $l$ and $r$ ($1 \\le l \\le r \\le n$) — the boundaries of the query. It is guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\nOutput\nFor each query, output in one line all record values (in sorted order) that occur strictly more than\n$$ \\left\\lfloor \\frac{r - l + 1}{3} \\right\\rfloor $$ times in the segment $[l, r]$.\nIf there are no such values, output -1.\nExample\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Input: 5 1 1 5 1 1 4 2 1 1 2 3 1 4 2 3 6 3 7 7 7 8 8 9 1 6 2 5 4 6 8 2 4 4 4 5 5 5 6 6 1 8 3 6 10 5 1 2 3 3 3 4 4 4 4 5 1 10 1 5 4 9 6 9 7 10 Output 5 1 1 2 7 7 8 8 4 5 5 4 3 4 4 4 Note\nIn the second test case, the array is $a = [1, 1, 2, 3]$ and there are two queries:\nQuery $(l, r) = (1, 4)$:\nThe length of the segment $len = r - l + 1 = 4$, the threshold $\\lfloor len/3 \\rfloor + 1 = 2$.\nOccurrences of numbers: $1 \\to 2$, $2 \\to 1$, $3 \\to 1$.\nOnly the number $1$ occurs at least $2$ times, so the answer is: 1.\nQuery $(l, r) = (2, 3)$:\nThe length of the segment $len = 2$, the threshold $\\lfloor len/3 \\rfloor + 1 = 1$.\nNumbers $1$ and $2$ occur once each, so the answer is: 1 2.\nIn the fourth test case, the array is $a = [4, 4, 4, 5, 5, 5, 6, 6]$ and there are two queries:\nQuery $(l, r) = (1, 8)$:\nThe length of the segment $len = 8$, the threshold $\\lfloor len/3 \\rfloor + 1 = 3$.\nOccurrences of numbers: $4 \\to 3$, $5 \\to 3$, $6 \\to 2$.\nOnly the numbers $4$ and $5$ occur at least $3$ times, so the answer is: 4 5.\nQuery $(l, r) = (3, 6)$:\nThe length of the segment $len = 4$, the threshold $\\lfloor len/3 \\rfloor + 1 = 2$.\nOccurrences of numbers: $4 \\to 1$, $5 \\to 3$.\nOnly the number $5$ occurs at least $2$ times, so the answer is: 5.\n","date":"2025-09-24T00:00:00Z","image":"https://ailec41.github.io/p/codeforces-2149g-solution/codeforce_hu_67e908996c4e5ce5.jpg","permalink":"https://ailec41.github.io/p/codeforces-2149g-solution/","title":"Codeforces 2149G Solution"},{"content":"Bits 为什么要用比特\n易于用双稳态元件存储 能在有噪声且不精确的电线上可靠传输 我们可以用二进制来表示浮点数。在一个二进制的小数中：\n小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、… 小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、… 因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。\n字节\n一个字节等于 8 比特 布尔代数 比特之间的关系（操作） 1 代表 true，0 代表 false Example：表示与操作集合\n表示方式： 一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集 如果 $a_j = 1，j ∈ A$ for example：{0, 3, 5, 6} 01101001 76543210 对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。\n对比逻辑运算符 \u0026amp;\u0026amp;、||、 ! Example：\n!0x41 → 0x00 !0x99 → 0x01 !!ox41 → 0x01 0x69 \u0026amp;\u0026amp; 0x55 → 0x01 p \u0026amp;\u0026amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用） 移位操作 左移：x \u0026laquo; y 向左移动位次，多余的bits扔掉，添加相对应数目的0 右移：x \u0026raquo; y 逻辑右移\n和左移类似 算数右移\n若第一个数为1，把原本填充的0改为填充1 整数编码 无符号数\n$B2U(X) = \\sum_{i = 0}^{w-1} x_i \\cdot 2^i $\n补码(Two\u0026rsquo;s Complement)\n$B2T(X) = -x_{w-1} \\cdot 2^{w-1} + \\sum_{i=0}^{w-2} x_i \\cdot 2^i$\n数值范围\nW = 16\nValue Type Formula / Binary Pattern Decimal Hex Binary Unsigned Values UMin 0 0 0x0000 00000000 00000000 UMax 2W - 1 65535 0xFFFF 11111111 11111111 Two\u0026rsquo;s Complement Values TMin -2W-1 / 100\u0026hellip;0 -32768 0x8000 10000000 00000000 TMax 2W-1 - 1 / 011\u0026hellip;1 32767 0x7FFF 01111111 11111111 Other Values -1 111\u0026hellip;1 -1 0xFFFF 11111111 11111111 0 000\u0026hellip;0 0 0x0000 00000000 00000000 因此我们可以得到一个关系如下：\n​\t$TMin = TMax + 1$\n​\t$UMax = 2 \\times TMax + 1$\n转换 有符号整型和无符号整型和十进制的转换关系如下：\n显然上述转换是可逆的：\n$\\text{U2B}(x)=\\text{B2U}^{-1}(x)$ $\\text{T2B}(x)=\\text{B2T}^{-1}(x)$ 利用复合关系可以得到有符号整型以及无符号整型的转换关系：\n对于$\\text {TMin} \\leqslant x \\leqslant \\text{TMax}$ $$ T 2 U_w(x)=\\left\\{\\begin{array}{ll} x+2^{w}, \u0026 x\u003c0 \\\\ x, \u0026 x \\geqslant 0 \\end{array}\\right. $$ 对于$0 \\leqslant x \\leqslant \\text{UMax}$ $$ U 2 T_{w}(u)=\\left\\{\\begin{array}{ll} u, \u0026 u \\leqslant \\text{TMax} \\\\ u-2^{w}, \u0026 u\u003e\\text{TMax} \\end{array}\\right. $$下图为补码到无符号数的转换关系\nC语言中的转换如下：\n1 2 3 4 5 6 7 8 9 int tx, ty; unsigned ux, uy; //显示转换 tx = (int) ux; uy = (unsigned) ty; //隐式转换 tx = ux; uy = ty 表达式求值规则 若单个表达式中同时出现无符号数与有符号数，则有符号值会被隐式转换为无符号数（包括比较运算 \u0026lt;、\u0026gt;、==、\u0026lt;=、\u0026gt;=）。\n举例：W = 32 位\n常量定义\nTMIN = -2,147,483,648 TMAX = 2,147,483,647 常量 1 常量 2 实际类型 关系 结果 说明 0 0U 无符号 \u0026lt; 假 两者均为 0 -1 0 有符号 \u0026lt; 真 普通有符号比较 -1 0U 无符号 \u0026gt; 真 -1 被转成 4294967295U 2147483647 -2147483648 有符号 \u0026gt; 真 普通有符号比较 2147483647U -2147483648 无符号 \u0026lt; 真 -2147483648 被转成 2147483648U -1 -2 有符号 \u0026gt; 真 普通有符号比较 (unsigned)-1 -2 无符号 \u0026gt; 真 -2 被转成 4294967294U 2147483647 2147483648U 无符号 \u0026lt; 真 前者 \u0026lt; 后者 2147483647 (int)2147483648U 有符号 \u0026gt; 真 后者溢出成 -2147483648 小结：有符号与无符号强制转换的基本规则 位模式保持不变\n强制转换时，内存中的 0/1 序列原样复制。\n仅重新解释\n同一段位模式，按目标类型（有符号或无符号）重新解读。\n可能产生“意外”\n数值可能突然加上或减去 2^W（W 为位数）。\n表达式中的混合类型\n只要表达式里同时出现signed int与unsigned int ，编译器会把 signed int 隐式转换成 unsigned int，再参与运算。\n扩展，截断 扩展 无符号扩展至需要在前面的bits补0,有符号扩展如下\n任务：\n给定w-bit的有符号整型x 将其转换为w+k-bit的有符号整型，值不变 规则：\n将符号位复制k份\n$X\u0026rsquo; = X_{w-1},\\dots,X_{w-1},X_{w-1},X_{w-2},\\dots,X_0$\n补码的符号扩展\n定义宽度为 $w$ 的位向量 $\\vec{x} = [x_{w-1}, x_{w-2}, \\dots, x_0]$ 和宽度为 $w\u0026rsquo;$ 的位向量 $\\vec{x}\u0026rsquo; = [x\u0026rsquo;{w\u0026rsquo;-1}, x\u0026rsquo;{w\u0026rsquo;-2}, \\dots, x\u0026rsquo;0]$，其中 $w\u0026rsquo; \u0026gt; w$。则$B2T_w(\\vec{x}) = B2T{w\u0026rsquo;}(\\vec{x}\u0026rsquo;)$，\n补码数值的符号扩展\n令$w\u0026rsquo; = w + k$，我们想要证明的是 $$ B2T_{w+k} ([x_{w-1}, \\cdots, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$下面的证明是对$k$进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了： $$ B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$展开左边的表达式，得到： $$ \\begin{aligned} B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) \u0026= -x_{w-1}2^w + \\sum_{i=0}^{w-1}x_i2^i \\\\ \u0026= -x_{w-1}2^w + x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}(2^w - 2^{w-1}) + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\end{aligned} $$我们使用的关键属性是$2^w - 2^{w-1} = 2^{w-1}$。因此，加上一个权值为$-2^w$的位，和将一个权值为 $-2^{w-1}$的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。\n截断 无符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2U}_w(X)=\\sum_{i=0}^{w-1} x_i\\cdot2^i $$截断为 $k$ 位后：\n$$ \\mathrm{B2U}_k(X)=\\sum_{i=0}^{k-1} x_i\\cdot2^i = \\mathrm{B2U}_w(X)\\bmod 2^k $$推导 $$ \\begin{aligned} B2U_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\mod 2^k \u0026= \\left[ \\sum_{i=0}^{w-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\left[ \\sum_{i=0}^{k-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\sum_{i=0}^{k-1} x_i 2^i \\\\ \u0026= B2U_k([x_{k-1}, x_{k-2}, \\cdots, x_0]) \\end{aligned} $$有符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2T}_w(X)=-x_{w-1}\\cdot2^{w-1}+\\sum_{i=0}^{w-2} x_i\\cdot2^i $$ 截断为 $k$ 位后：\n$$ \\mathrm{B2T}_k(X)=-x_{k-1}\\cdot2^{k-1}+\\sum_{i=0}^{k-2} x_i\\cdot2^i = \\mathrm{U2T}_k\\!\\bigl(\\mathrm{B2U}_w(X)\\bmod 2^k\\bigr) $$","date":"2025-09-24T00:00:00Z","image":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/csapp_hu_d6260cc969558569.jpg","permalink":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/","title":"lecture02 Bits,Bytes and Integer"}]