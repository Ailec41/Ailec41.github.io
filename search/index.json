[{"content":"日常的训练，回顾一下做的几道题，实现不发\nICPC Hangzhou Reginal F Fuzzy Ranking 不太会做，看了一下题解，下面是看完题解后的思路\n直接为任意“前→后”对连边会太多，在同一排列中，只连相邻元素 $a_j\\to a_{j+1}$ 即可：因为一条从前往后的有向路径已经能覆盖该排列中任意“前→后”的可达关系。对所有 $k$ 个排列加边\n对图做一次 Tarjan/Kosaraju缩点，得到每个学校所属的 SCC 编号bel[x]，以及按拓扑序逆序排列的分量列表 scc。把每个榜单按 bel重新映射成“分量编号序列”。\n在某个榜单中，原先相邻的两点之间有边，缩点后相同分量的编号在该榜单上必然连成一段。因此每个榜单都可以被切成若干段，每段恰好由同一个 SCC 的元素组成。这个性质让我们可以把任意区间 $[l,r]$ 拆解为：左端一个不完整段 + 中间若干完整段 + 右端一个不完整段。\n对每个榜单i:\nSegment：对位置轴进行分段。令 Segment= (L, R) 表示pos所在的那段在该榜单上的左右端点下标。线性扫，遇到一段相同编号的区间 $[L,R]$ 就把这对端点填给其中的每个位置。\ndp 前缀：统计从开头到位置 $j$ 为止、同段内能形成的“模糊对”数量。若 $j$ 落在段 $[L,R]$，新增的成对数等于该段里被纳入的元素个数减一，即 $j-L$。因此定义 $$ dp[id][j] = dp[id][j-1] + (j-L). $$ 这样任意区间 $[x,y]$ 的“在同一段内形成的对数”就能通过 $dp$ 差分 $dp[id][y]-dp[id][x]$ 得到。\n总计复杂度$O(nk)$\nCF1841E Fill the Matrix 题目说有一个$n * n$的正方形矩阵，在第$i$列，前$a_i$个格子都是黑色，剩下的格子是白色，在矩阵放入1到m到整数，每个格子最多放一个且黑色格子不能放，定义美丽值为数字 $j$ 和 $j+1$ 位于同一行，且 $j+1$ 位于 $j$ 的右边相邻的格子，求放置m个整数后最大美丽值\n我们一定先选一个最长的白色格子全填进去，直到填满或者数不够。因为如果不继续填等于说最后填的那个数旁边的格子就浪费了，所以关键就在于要把所有行的白色连续横段都计算出来，按长度分组，记为cnt[n]，代表长度n的横段有几个，直接暴力扫迷线维护复杂度是$O(n^2)$的，直接炸了，所以我们用线段树来维护最大值和位置然后再分治来统计cnt数组，相当于构建一颗笛卡尔树，每次把区间按最大值分为左右两部分，统计每层能产生的白格段，最后用贪心计算答案就可以了，这样最后复杂度就控制在$O(nlogn)$\nCF2056D Unique Median 2200 给了一个整数数组b，当排序后满足$b⌊\\frac{m+1}{2}⌋=b⌈\\frac{m+1}{2}⌉$时我们说数组是好的，题目说给一个长度为n的数组a，计算好子数组数量\n首先观察好数组定义，我们可以很容易发现奇数长度的数组一定是好数组，所以我们只要看偶数长度的数组就可以了，很困难，想了一段时间，一开始的想法是如果我们要让偶数的数组是好的，那么当且仅当存在某个数$v$，使得在选取的子数组中$v \\ge m/2$，也就是说至少一半都是同一个数，但是肯定会有重复用容斥修正，减掉重复的就可以，实现很麻烦，写了很久，而且还发现是错误的，对于[1,1,2,3]按照这个思路明显错的，而且发现正着处理非常麻烦困难，于是决定反向试试，从所有子数组中减掉\u0026quot;坏的\u0026quot;，再修正\n很快就发现了一些东西，对于一个偶数的数组，只要让排序后第k个数小于k+1个数一定是坏的，再具体点，我们选定两个相邻的数x，y，我们只要让左中位数小于等于x，右中位数大于等于y就可以了，然后用前缀和+map即可，并且小于等于x的数的数量和大于等于y的数字数量必须要一样多，那么我们可以把数组按照值分为3类，一种小于等于x我们记为-1，大于等于y记为+1，介于x和y之间的我们直接清空，因为出现就相当于直接破坏了我们的数组\n最后就是用容斥进行修正，只要x和y相差超过2就记为重复的减掉就可以了\nCF1854A2 Dual (Hard Version) 一道思维题，给了一个数组，可以对于$i,j$的元素进行操作，使得$a_i := a_i + a_j$\n要求在31次操作内让数组不递减\n首先当所有元素都大于等于0或者全部都小于等于0的时候很显然，我们只需要把右边的数依次加上左边的数肯定是对的（小于等于0同理反过来就行）\n所以关键是要看数组里有正有负，我们设最大的正数是mx，绝对值最大的负数是mi，正数数量是cp，负数数量是cm，那么我们有两种选择，一种是都统一成非负，一种是统一成非正，只要符号统一我们就方便了，拿统一非负举例（非正同理），我们其实就是要让最大的正数足够大，能够覆盖所有负数，我们首先计算mx经过几次翻倍可以大于mi，然后让他翻倍，之后让所有的负数都加上这个mx它们都变成正数了，然后我们就判断一下这两种选择哪个更优即可\n","date":"2025-10-09T00:00:00Z","image":"https://ailec41.github.io/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/codeforce_%E5%89%AF%E6%9C%AC_hu_63f1156f535282a.jpg","permalink":"https://ailec41.github.io/p/icpc%E6%97%A5%E5%B8%B8%E8%AE%AD%E7%BB%8301/","title":"ICPC日常训练01"},{"content":"G. Buratsuta 3 time limit per test: 4.5 seconds\nmemory limit per test: 256 megabytes\nIn the ruthless world of Blue Lock, Buratsuta 3 is a trio selected to overthrow the reigning champions and lead the Japan U-20 team to glory. Sae Itoshi has already secured his place as the first participant; the remaining two spots will be contested in the tough Side-B selection.\nTo test the strategic abilities of the candidates, Buratsuta has posed the following challenge:\nYou are given an array of $n$ integers called performance records and $q$ queries.\nEach query specifies a subarray $[l, r]$. In this subarray, find all record values that occur strictly more than: $$ \\left\\lfloor \\frac{r - l + 1}{3} \\right\\rfloor $$ times.\nInput\nEach test consists of several test cases.\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$) — the number of records and the number of queries. The second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — the performance records. Each of the following $q$ lines contains two integers $l$ and $r$ ($1 \\le l \\le r \\le n$) — the boundaries of the query. It is guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\nOutput\nFor each query, output in one line all record values (in sorted order) that occur strictly more than\n$$ \\left\\lfloor \\frac{r - l + 1}{3} \\right\\rfloor $$ times in the segment $[l, r]$.\nIf there are no such values, output -1.\nExample\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Input: 5 1 1 5 1 1 4 2 1 1 2 3 1 4 2 3 6 3 7 7 7 8 8 9 1 6 2 5 4 6 8 2 4 4 4 5 5 5 6 6 1 8 3 6 10 5 1 2 3 3 3 4 4 4 4 5 1 10 1 5 4 9 6 9 7 10 Output 5 1 1 2 7 7 8 8 4 5 5 4 3 4 4 4 Note\nIn the second test case, the array is $a = [1, 1, 2, 3]$ and there are two queries:\nQuery $(l, r) = (1, 4)$:\nThe length of the segment $len = r - l + 1 = 4$, the threshold $\\lfloor len/3 \\rfloor + 1 = 2$.\nOccurrences of numbers: $1 \\to 2$, $2 \\to 1$, $3 \\to 1$.\nOnly the number $1$ occurs at least $2$ times, so the answer is: 1.\nQuery $(l, r) = (2, 3)$:\nThe length of the segment $len = 2$, the threshold $\\lfloor len/3 \\rfloor + 1 = 1$.\nNumbers $1$ and $2$ occur once each, so the answer is: 1 2.\nIn the fourth test case, the array is $a = [4, 4, 4, 5, 5, 5, 6, 6]$ and there are two queries:\nQuery $(l, r) = (1, 8)$:\nThe length of the segment $len = 8$, the threshold $\\lfloor len/3 \\rfloor + 1 = 3$.\nOccurrences of numbers: $4 \\to 3$, $5 \\to 3$, $6 \\to 2$.\nOnly the numbers $4$ and $5$ occur at least $3$ times, so the answer is: 4 5.\nQuery $(l, r) = (3, 6)$:\nThe length of the segment $len = 4$, the threshold $\\lfloor len/3 \\rfloor + 1 = 2$.\nOccurrences of numbers: $4 \\to 1$, $5 \\to 3$.\nOnly the number $5$ occurs at least $2$ times, so the answer is: 5.\n","date":"2025-09-29T00:00:00Z","image":"https://ailec41.github.io/p/codeforces-2149g-solution/codeforce_hu_63f1156f535282a.jpg","permalink":"https://ailec41.github.io/p/codeforces-2149g-solution/","title":"Codeforces 2149G Solution"},{"content":"","date":"2025-09-28T00:00:00Z","image":"https://ailec41.github.io/p/lab1-datalab/csapp_hu_113ffe23e1ef718.jpg","permalink":"https://ailec41.github.io/p/lab1-datalab/","title":"Lab1 DataLab"},{"content":"加法 无符号加法 无符号的加法很简单，和二进制加法一样，只不过要把overflow的删除，并且把结果取模即可\n检测无符号数中加法的溢出\n令 $s = U +_w^u V$ 为无符号整数 $U$ 和 $V$ 的和，那么当且仅当 $s \u0026lt; U$（或等价的 $s \u0026lt; V$）时产生溢出，这是因为：\n$$ \\begin{aligned} s \u0026= U + V - 2^w \u003c U \\\\ s \u0026= U + V - 2^w \u003c V \\end{aligned} $$补码加法 ![](截屏2025-09-28 15.57.52.jpg)\n对满足 $-2^{w-1} \\leq x$，$y \\leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：\n$$ x +_w^t y = \\begin{cases} x + y - 2^w, \u0026 2^{w-1} \\leq x + y \\quad \\text{正溢出} \\\\ x + y, \u0026 -2^{w-1} \\leq x + y \u003c 2^{w-1} \\quad \\text{正常} \\\\ x + y + 2^w, \u0026 x + y \u003c -2^{w-1} \\quad \\text{负溢出} \\end{cases} $$ 两个数的$w$位补码之和与无符号之和有完全相同的位级表示\n利用左移做乘法\n大多数机器中左移比乘法快 编译器会自动生成这样的代码 方法的证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，那么 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]$ 给出了 $x2^k$ 的 $w+k$ 位二进制表示：\n$$ \\begin{aligned} B2U_{w+k}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= x 2^{k} \\end{aligned} $$对于固定长度的表示，高 $k$ 位被丢弃，左移 $k$ 位的二进制表示为 $$ \\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right] $$所以 $$ \\begin{aligned} B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) \u0026= \\sum_{i=0}^{w-k-1} x_{i} 2^{i+k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-k-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\\\ \u0026= \\left[\\sum_{i=0}^{w-1} x_{i} 2^{i}\\right] \\cdot 2^{k} \\mod 2^w \\\\ \u0026= x2^k \\mod 2^w \\end{aligned} $$所以对于无符号整数 $$ B2U_{w}\\left(\\left[x_{w-k-1}, x_{w-k-2}, \\cdots, x_{0}, 0, \\cdots, 0\\right]\\right) = \\text{UMult}_w(x,2^k) $$对于有符号整数，利用 $$ \\text{TMult}_w(u,v) = U2T_w((u \\cdot v) \\mod 2^w) $$ 可以得到相同的结果。\n一般情形\n现在考虑一般的情形，假设我们需要计算 $u \\times K$，其中 $K$ 为常数，将 $K$ 表达为一组 $0$ 和 $1$ 交替的序列 $$ [(0 \\cdots 0)(1 \\cdots 1)(0 \\cdots 0) \\cdots (1 \\cdots 1)] $$考虑一组从位置 $n$ 到位置 $m$ 的连续 $1$，那么可以用如下方式计算这部分的对于乘积的影响： $$ \\begin{aligned} \u0026(x \u003c\u003c n) + (x \u003c\u003c (n-1)) + \\cdots + (x \u003c\u003c m) \\\\ \u0026(x \u003c\u003c (n+1)) - (x \u003c\u003c m) \\end{aligned} $$移位操作和二进制乘除法的联系 使用移位操作代替除以 2 的幂（无符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用逻辑移位 证明：\n假设 $x$ 的 $w$ 位二进制表示为 $\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]$，右移 $k$ 位的二进制表示为 $\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]$\n$$ \\begin{aligned} B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) \u0026= \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} \\\\ B2U_{w}\\left(\\left[x_{w-1}, x_{w-2}, \\cdots, x_{0}\\right]\\right) \u0026= \\sum_{i=0}^{w-1} x_{i} 2^{i} \\\\ \u0026= 2^k \\sum_{i=0}^{w-k-1} x_{i+k} 2^{i} + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\\\ \u0026= 2^k B2U_w(\\left[0, \\cdots, 0, x_{w-1}, x_{w-2}, \\cdots, x_{k}\\right]) + \\sum_{i=0}^{k-1} x_{i} 2^{i} \\end{aligned} $$所以 $$ \\lfloor x / 2^{k} \\rfloor = x \u003e\u003e k $$使用移位操作代替除以 2 的幂（有符号） $u \u0026raquo; k$ 给出 $\\lfloor u / 2^{k} \\rfloor$ 使用算数移位 当 $u \u0026gt; 0$ 时上述方法和无符号情形一致，但是当 $u \u0026lt; 0$ 时则会产生有问题的结果，例如取 $u = -12340$：\n考虑 $k=4,8$ 时的结果，在 C 语言中实际结果为 $-771$ 和 $-48$，之所以和 C 语言中的结果不同，是因为上述算法朝着离 $0$ 更远的方向舍入，所以当 $u \u0026lt; 0$ 时要向上舍入，达到上述效果利用如下事实即可 $$ \\lceil x / y \\rceil = \\lfloor (x + y - 1) / y \\rfloor $$Unsigned 必须做一个明确的分配而不是暗示\n容易犯错误，例如下面的代码会出现无限循环\n1 2 3 unsigend i; for(i = cnt - 2;i \u0026gt;= 2;i --) a[i] += a[i + 1]; 可能会变的很诡异\n1 2 3 #define DELTA sizeof(int)//默认int的size是一个unsigned的size_t int i; for(i = CNT;i - DELTA \u0026gt;= 0;i -=DELTA)//和上面的代码出现一样的问题 正确的代码如下\n1 2 3 size_t i; for (i = cnt-2; i \u0026lt; cnt; i--) a[i] += a[i+1]; 什么时候用无符号整数\n执行模块化算术时使用\n多精度算术 在使用位表示集时使用\n逻辑右移，无符号扩展 （最好不要用unsigned）\n内存中数字的一些底层表示 Word Size 硬件本身并不一定定义字长大小\n任何给定的计算机都具有字长\n直到现在，大部份机器都采用32 bits(4 bytes)作为字长\n地址限制为4 GB($2^{32}$bytes) 越来越多机器具有64位字长\n机器仍然支持多种数据格式\n字长的分数或整数倍 但总是整数比特 比特顺序 分为大端法和小端法\nExample 变量x的value是0x01234567 地址是0x100 ","date":"2025-09-26T00:00:00Z","image":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/csappp_hu_d6260cc969558569.jpg","permalink":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/","title":"lecture03 Bits,Bytes and Integer cout"},{"content":"Bits 为什么要用比特\n易于用双稳态元件存储 能在有噪声且不精确的电线上可靠传输 我们可以用二进制来表示浮点数。在一个二进制的小数中：\n小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、… 小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、… 因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。\n字节\n一个字节等于 8 比特 布尔代数 比特之间的关系（操作） 1 代表 true，0 代表 false Example：表示与操作集合\n表示方式： 一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集 如果 $a_j = 1，j ∈ A$ for example：{0, 3, 5, 6} 01101001 76543210 对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。\n对比逻辑运算符 \u0026amp;\u0026amp;、||、 ! Example：\n!0x41 → 0x00 !0x99 → 0x01 !!ox41 → 0x01 0x69 \u0026amp;\u0026amp; 0x55 → 0x01 p \u0026amp;\u0026amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用） 移位操作 左移：x \u0026laquo; y 向左移动位次，多余的bits扔掉，添加相对应数目的0 右移：x \u0026raquo; y 逻辑右移\n和左移类似 算数右移\n若第一个数为1，把原本填充的0改为填充1 整数编码 无符号数\n$B2U(X) = \\sum_{i = 0}^{w-1} x_i \\cdot 2^i $\n补码(Two\u0026rsquo;s Complement)\n$B2T(X) = -x_{w-1} \\cdot 2^{w-1} + \\sum_{i=0}^{w-2} x_i \\cdot 2^i$\n数值范围\nW = 16\nValue Type Formula / Binary Pattern Decimal Hex Binary Unsigned Values UMin 0 0 0x0000 00000000 00000000 UMax 2W - 1 65535 0xFFFF 11111111 11111111 Two\u0026rsquo;s Complement Values TMin -2W-1 / 100\u0026hellip;0 -32768 0x8000 10000000 00000000 TMax 2W-1 - 1 / 011\u0026hellip;1 32767 0x7FFF 01111111 11111111 Other Values -1 111\u0026hellip;1 -1 0xFFFF 11111111 11111111 0 000\u0026hellip;0 0 0x0000 00000000 00000000 因此我们可以得到一个关系如下：\n​\t$TMin = TMax + 1$\n​\t$UMax = 2 \\times TMax + 1$\n转换 有符号整型和无符号整型和十进制的转换关系如下：\n显然上述转换是可逆的：\n$\\text{U2B}(x)=\\text{B2U}^{-1}(x)$ $\\text{T2B}(x)=\\text{B2T}^{-1}(x)$ 利用复合关系可以得到有符号整型以及无符号整型的转换关系：\n对于$\\text {TMin} \\leqslant x \\leqslant \\text{TMax}$ $$ T 2 U_w(x)=\\left\\{\\begin{array}{ll} x+2^{w}, \u0026 x\u003c0 \\\\ x, \u0026 x \\geqslant 0 \\end{array}\\right. $$ 对于$0 \\leqslant x \\leqslant \\text{UMax}$ $$ U 2 T_{w}(u)=\\left\\{\\begin{array}{ll} u, \u0026 u \\leqslant \\text{TMax} \\\\ u-2^{w}, \u0026 u\u003e\\text{TMax} \\end{array}\\right. $$下图为补码到无符号数的转换关系\nC语言中的转换如下：\n1 2 3 4 5 6 7 8 9 int tx, ty; unsigned ux, uy; //显示转换 tx = (int) ux; uy = (unsigned) ty; //隐式转换 tx = ux; uy = ty 表达式求值规则 若单个表达式中同时出现无符号数与有符号数，则有符号值会被隐式转换为无符号数（包括比较运算 \u0026lt;、\u0026gt;、==、\u0026lt;=、\u0026gt;=）。\n举例：W = 32 位\n常量定义\nTMIN = -2,147,483,648 TMAX = 2,147,483,647 常量 1 常量 2 实际类型 关系 结果 说明 0 0U 无符号 \u0026lt; 假 两者均为 0 -1 0 有符号 \u0026lt; 真 普通有符号比较 -1 0U 无符号 \u0026gt; 真 -1 被转成 4294967295U 2147483647 -2147483648 有符号 \u0026gt; 真 普通有符号比较 2147483647U -2147483648 无符号 \u0026lt; 真 -2147483648 被转成 2147483648U -1 -2 有符号 \u0026gt; 真 普通有符号比较 (unsigned)-1 -2 无符号 \u0026gt; 真 -2 被转成 4294967294U 2147483647 2147483648U 无符号 \u0026lt; 真 前者 \u0026lt; 后者 2147483647 (int)2147483648U 有符号 \u0026gt; 真 后者溢出成 -2147483648 小结：有符号与无符号强制转换的基本规则 位模式保持不变\n强制转换时，内存中的 0/1 序列原样复制。\n仅重新解释\n同一段位模式，按目标类型（有符号或无符号）重新解读。\n可能产生“意外”\n数值可能突然加上或减去 2^W（W 为位数）。\n表达式中的混合类型\n只要表达式里同时出现signed int与unsigned int ，编译器会把 signed int 隐式转换成 unsigned int，再参与运算。\n扩展，截断 扩展 无符号扩展至需要在前面的bits补0,有符号扩展如下\n任务：\n给定w-bit的有符号整型x 将其转换为w+k-bit的有符号整型，值不变 规则：\n将符号位复制k份\n$X\u0026rsquo; = X_{w-1},\\dots,X_{w-1},X_{w-1},X_{w-2},\\dots,X_0$\n补码的符号扩展\n定义宽度为 $w$ 的位向量 $\\vec{x} = [x_{w-1}, x_{w-2}, \\dots, x_0]$ 和宽度为 $w\u0026rsquo;$ 的位向量 $\\vec{x}\u0026rsquo; = [x\u0026rsquo;{w\u0026rsquo;-1}, x\u0026rsquo;{w\u0026rsquo;-2}, \\dots, x\u0026rsquo;0]$，其中 $w\u0026rsquo; \u0026gt; w$。则$B2T_w(\\vec{x}) = B2T{w\u0026rsquo;}(\\vec{x}\u0026rsquo;)$，\n补码数值的符号扩展\n令$w\u0026rsquo; = w + k$，我们想要证明的是 $$ B2T_{w+k} ([x_{w-1}, \\cdots, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$下面的证明是对$k$进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了： $$ B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) $$展开左边的表达式，得到： $$ \\begin{aligned} B2T_{w+1} ([x_{w-1}, x_{w-1}, x_{w-2}, \\cdots, x_0]) \u0026= -x_{w-1}2^w + \\sum_{i=0}^{w-1}x_i2^i \\\\ \u0026= -x_{w-1}2^w + x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}(2^w - 2^{w-1}) + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}x_i2^i \\\\ \u0026= B2T_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\end{aligned} $$我们使用的关键属性是$2^w - 2^{w-1} = 2^{w-1}$。因此，加上一个权值为$-2^w$的位，和将一个权值为 $-2^{w-1}$的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。\n截断 无符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2U}_w(X)=\\sum_{i=0}^{w-1} x_i\\cdot2^i $$截断为 $k$ 位后：\n$$ \\mathrm{B2U}_k(X)=\\sum_{i=0}^{k-1} x_i\\cdot2^i = \\mathrm{B2U}_w(X)\\bmod 2^k $$推导 $$ \\begin{aligned} B2U_w([x_{w-1}, x_{w-2}, \\cdots, x_0]) \\mod 2^k \u0026= \\left[ \\sum_{i=0}^{w-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\left[ \\sum_{i=0}^{k-1} x_i 2^i \\right] \\mod 2^k \\\\ \u0026= \\sum_{i=0}^{k-1} x_i 2^i \\\\ \u0026= B2U_k([x_{k-1}, x_{k-2}, \\cdots, x_0]) \\end{aligned} $$有符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2T}_w(X)=-x_{w-1}\\cdot2^{w-1}+\\sum_{i=0}^{w-2} x_i\\cdot2^i $$ 截断为 $k$ 位后：\n$$ \\mathrm{B2T}_k(X)=-x_{k-1}\\cdot2^{k-1}+\\sum_{i=0}^{k-2} x_i\\cdot2^i = \\mathrm{U2T}_k\\!\\bigl(\\mathrm{B2U}_w(X)\\bmod 2^k\\bigr) $$","date":"2025-09-24T00:00:00Z","image":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/csapp_hu_d6260cc969558569.jpg","permalink":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/","title":"lecture02 Bits,Bytes and Integer"}]