[{"content":"Bits 为什么要用比特\n易于用双稳态元件存储 能在有噪声且不精确的电线上可靠传输 我们可以用二进制来表示浮点数。在一个二进制的小数中：\n小数点左边的第一位权重为 2^0，向左依次为 2^1、2^2、… 小数点右边的第一位权重为 2^-1，向右依次为 2^-2、2^-3、… 因此，如果将数字写成 32 位或者 64 位的字符串会很麻烦。通常将 4 bits 为一组，用十六进制表示。这样十六进制与二进制的转换就非常方便。\n字节\n一个字节等于 8 比特 布尔代数 比特之间的关系（操作） 1 代表 true，0 代表 false Example：表示与操作集合\n表示方式： 一个长度为 $w $的位向量表示集合 ${0, 1, …, w-1}$ 的子集 如果 $a_j = 1，j ∈ A$ for example：{0, 3, 5, 6} 01101001 76543210 对于上面的这个例子，“01101001”代表的就是 “76543210” 中各个位的数字在集合中是否出现，出现即为 1，反之为 0。\n对比逻辑运算符 \u0026amp;\u0026amp;、||、 ! Example：\n!0x41 → 0x00 !0x99 → 0x01 !!ox41 → 0x01 0x69 \u0026amp;\u0026amp; 0x55 → 0x01 p \u0026amp;\u0026amp; *p（避免空指针访问，如果 p 是 NULL，就不会解引用） 移位操作 左移：x \u0026laquo; y 向左移动位次，多余的bits扔掉，添加相对应数目的0 右移：x \u0026raquo; y 逻辑右移\n和左移类似 算数右移\n若第一个数为1，把原本填充的0改为填充1 整数编码 无符号数\n$B2U(X) = \\sum_{i = 0}^{w-1} x_i \\cdot 2^i $\n补码(Two\u0026rsquo;s Complement)\n$B2T(X) = -x_{w-1} \\cdot 2^{w-1} + \\sum_{i=0}^{w-2} x_i \\cdot 2^i$\n数值范围\nW = 16\nValue Type Formula / Binary Pattern Decimal Hex Binary Unsigned Values UMin 0 0 0x0000 00000000 00000000 UMax 2W - 1 65535 0xFFFF 11111111 11111111 Two\u0026rsquo;s Complement Values TMin -2W-1 / 100\u0026hellip;0 -32768 0x8000 10000000 00000000 TMax 2W-1 - 1 / 011\u0026hellip;1 32767 0x7FFF 01111111 11111111 Other Values -1 111\u0026hellip;1 -1 0xFFFF 11111111 11111111 0 000\u0026hellip;0 0 0x0000 00000000 00000000 因此我们可以得到一个关系如下：\n​\t$TMin = TMax + 1$\n​\t$UMax = 2 \\times TMax + 1$\n转换 有符号整型和无符号整型和十进制的转换关系如下：\n显然上述转换是可逆的：\n$\\text{U2B}(x)=\\text{B2U}^{-1}(x)$ $\\text{T2B}(x)=\\text{B2T}^{-1}(x)$ 利用复合关系可以得到有符号整型以及无符号整型的转换关系：\n对于$\\text {TMin} \\leqslant x \\leqslant \\text{TMax}$ $$ T 2 U_w(x)=\\left\\{\\begin{array}{ll} x+2^{w}, \u0026 x\u003c0 \\\\ x, \u0026 x \\geqslant 0 \\end{array}\\right. $$ 对于$0 \\leqslant x \\leqslant \\text{UMax}$ $$ U 2 T_{w}(u)=\\left\\{\\begin{array}{ll} u, \u0026 u \\leqslant \\text{TMax} \\\\ u-2^{w}, \u0026 u\u003e\\text{TMax} \\end{array}\\right. $$下图为补码到无符号数的转换关系\nC语言中的转换如下：\n1 2 3 4 5 6 7 8 9 int tx, ty; unsigned ux, uy; //显示转换 tx = (int) ux; uy = (unsigned) ty; //隐式转换 tx = ux; uy = ty 表达式求值规则 若单个表达式中同时出现无符号数与有符号数，则有符号值会被隐式转换为无符号数（包括比较运算 \u0026lt;、\u0026gt;、==、\u0026lt;=、\u0026gt;=）。\n举例：W = 32 位\n常量定义\nTMIN = -2,147,483,648 TMAX = 2,147,483,647 常量 1 常量 2 实际类型 关系 结果 说明 0 0U 无符号 \u0026lt; 假 两者均为 0 -1 0 有符号 \u0026lt; 真 普通有符号比较 -1 0U 无符号 \u0026gt; 真 -1 被转成 4294967295U 2147483647 -2147483648 有符号 \u0026gt; 真 普通有符号比较 2147483647U -2147483648 无符号 \u0026lt; 真 -2147483648 被转成 2147483648U -1 -2 有符号 \u0026gt; 真 普通有符号比较 (unsigned)-1 -2 无符号 \u0026gt; 真 -2 被转成 4294967294U 2147483647 2147483648U 无符号 \u0026lt; 真 前者 \u0026lt; 后者 2147483647 (int)2147483648U 有符号 \u0026gt; 真 后者溢出成 -2147483648 小结：有符号与无符号强制转换的基本规则 位模式保持不变\n强制转换时，内存中的 0/1 序列原样复制。\n仅重新解释\n同一段位模式，按目标类型（有符号或无符号）重新解读。\n可能产生“意外”\n数值可能突然加上或减去 2^W（W 为位数）。\n表达式中的混合类型\n只要表达式里同时出现signed int与unsigned int ，编译器会把 signed int 隐式转换成 unsigned int，再参与运算。\n扩展，截断 扩展 无符号扩展至需要在前面的bits补0,有符号扩展如下\n任务：\n给定w-bit的有符号整型x 将其转换为w+k-bit的有符号整型，值不变 规则：\n将符号位复制k份\n$X\u0026rsquo; = X_{w-1},\\dots,X_{w-1},X_{w-1},X_{w-2},\\dots,X_0$\n截断 无符号截断\n原始 $w$ 位：\n$\\mathrm{B2U}w(X)=\\sum{i=0}^{w-1} x_i\\cdot2^i$\n截断为 $k$ 位后：\n$\\mathrm{B2U}k(X)=\\sum{i=0}^{k-1} x_i\\cdot2^i = \\mathrm{B2U}_w(X)\\bmod 2^k$\n有符号截断\n原始 $w$ 位：\n$$ \\mathrm{B2T}_w(X)=-x_{w-1}\\cdot2^{w-1}+\\sum_{i=0}^{w-2} x_i\\cdot2^i $$ 截断为 $k$ 位后：\n$$ \\mathrm{B2T}_k(X)=-x_{k-1}\\cdot2^{k-1}+\\sum_{i=0}^{k-2} x_i\\cdot2^i = \\mathrm{U2T}_k\\!\\bigl(\\mathrm{B2U}_w(X)\\bmod 2^k\\bigr) $$","date":"2025-09-24T00:00:00Z","image":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/csapp_hu_113ffe23e1ef718.jpg","permalink":"https://ailec41.github.io/p/lecture02-bitsbytes-and-integer/","title":"lecture02 Bits,Bytes and Integer"},{"content":"","date":"2025-09-24T00:00:00Z","image":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/csappp_hu_d6260cc969558569.jpg","permalink":"https://ailec41.github.io/p/lecture03-bitsbytes-and-integer-cout/","title":"lecture03 Bits,Bytes and Integer cout"}]